#!/usr/bin/env python3

# This Python file uses the following encoding: utf-8

import sys

from PySide2.QtCore import *
from PySide2.QtWidgets import *
from PySide2.QtGui import *
from PySide2.QtPrintSupport import *
from PySide2.QtUiTools import *
TESTICON="option.svg"
TESTICONLINKED="linked.svg"
TESTICONFIXED="fixed.svg"
ICONCLOSE="close.svg"
from sys import exit
from time import time
from enum import Enum,IntEnum,auto,unique

# Thread limit
NUM_THREADS = 1
# Debug level for internal resolver & movement, printing terminal messages
#  values: 0 (disabled), 1 (less verbose), 2 (full debug messages)
DEBUG_LEVEL = 2
# Replay longer queries, auto-activating debug_level = 2 for debug sequence
PAUSE_WHEN_SEEMS_WRONG = True
@unique
class Direction(IntEnum):
    UP = 0
    DOWN = 1
    FIXED = 2

class Color(Enum):
    MAGENTA = '\033[95m'
    BLUE = '\033[94m'
    GREEN = '\033[92m'
    YELLOW = '\033[93m'
    RED = '\033[91m' 
    CYAN = '\033[96m'
    RESET = '\033[0m'
    BOLD = '\033[1m'
    BLINK = '\033[5m'
    UNDERLINE = '\033[4m'

    def makecolor(thing,color):
        if not isinstance(color,Color):
            return
        return '{}{}{}'.format(color.value,thing,Color.RESET.value)
     
class Resolver:
    # class testclass:
    #     A = '00 00 10 11 01 10 00 01 01'
    #     # A 0 0
    #     # B 0 0
    #     # C 1 0
    #     # D 1 1
    #     # E 0 1
    #     # F 1 0
    #     # G 0 0
    #     # H 0 1
    #     # I 0 1

    def dprint(self,msg,found):
        if self.debug_level < 2:
            return
        if not msg:
            msg = "<empty>"
        if found is True:
            msg = Color.makecolor(msg,Color.GREEN)
        elif found is None:
            msg = Color.makecolor(msg,Color.YELLOW)
        else:
            msg = Color.makecolor(msg,Color.RED)
        print(msg)

    def __init__(self,*args,**kwargs):
        self.terminate = False
        thing = kwargs.get('thing',None)
        complete = kwargs.get('complete',None)
        debug_level = kwargs.get('debug_level',None)
        for i,value in enumerate(args,1):
            if i == 1 and not thing:
                thing = value
            if i == 2 and not complete:
                complete = value
            if i == 3 and not debug_level:
                debug_level = value

        if not complete:
            complete = False
        if not debug_level:
            debug_level = 0
        self.thing = thing

        self.complete = complete

        self.debug_info = { 'counter' : {'partial':0,'full':0}, 'times' : [] }
        self.debug_level = debug_level
        
        self.combination = ''
        self.levels = 0
        self.options = {}
        self.results = []
        self.conditions = []
        if not self.initialize(self.thing):
            print(Color.makecolor('Not valid',Color.RED))
            exit(1)

    def abort(self):
        self.terminate = True
    # function to print metric counters when debugging
    def print_debug_info(self):
        if self.debug_level > 0:
            acu = 0.0
            s = []
            for ini,end in self.debug_info['times']:
                cur = end-ini
                acu += cur
                s.append('{0:4.2f}'.format(cur))
            print("Checks: {0:10d}/{1:<10d} [ TOTAL {2:4.2f} seconds ] [{3:s}]".format(self.debug_info['counter']['partial'],self.debug_info['counter']['full'],acu,'+'.join(s)))

    # Configure conditions into resolver, conditions represent questions that resolver try to answer with valid combination
    # Example) if we want to answer if one row can go down, i will add one or more conditions that this row need to be on any of target rows
    #
    # Parameters:
    # item: string with one or more characters representing rows
    # direction: enum setting direction
    def addCondition(self,item,direction):
        item_tmp = ''
        # If item is a linked item, link all elements into condition
        for i in item:
            if self.options['names'][i].get('linked'):
                linked_str = ''.join(self.options['names'][i].get('list'))
                if linked_str not in item_tmp:
                    item_tmp += linked_str
            else:
                item_tmp += i
        item = item_tmp
        # Get starting item position
        i = self.combination.index(item)
        # If fixed position, add condition with only one possible position for each
        if direction == Direction.FIXED:
            i+=1
            for x in item:
                self.conditions.append((x,[i]))
                i+=1
        # If is going up, add a list of possible positions for each element
        elif direction == Direction.UP:
            offset=-1
            for x in item:
                offset+=1
                l = list(range(i+offset,-1+offset,-1))
                # Conditions going up need to be reversed with nearest (greatest) positions first
                self.conditions.append((x,l))
        # If is going down, add a list of possible positions for each element
        elif direction == Direction.DOWN:
            offset=1
            for x in item:
                offset+=1
                # Conditions going down need to be growing with nearest (lowest) positions first
                self.conditions.append((x,list(range(i+offset,self.levels+2))))

    # Check if it's valid combination
    # Combination (thing) can be complete or partial combination, this function validate partial combination to avoid go through 
    # branches that wouldn't end succesfully because conditions applied over partial combination are failed
    #
    # This function ends with 3 results:
    # False: Wrong combination(thing), expansion tree needs to be cut
    # None: Not wrong combination until now, but it's not complete, any possible result can be found later in this branch
    # True: Good combination was found, this combination agree all condition and it's full lenght
    def validate(self,thing):
        l = len(thing)
        # It's full when it's at lowest level of recursion configured
        full = l == self.levels

        # Debug counters
        if self.debug_level > 0:
            if full:
                self.debug_info['counter']['full'] += 1
            else:
                self.debug_info['counter']['partial'] += 1

        # First validation, combination it's empty
        if not thing:
            self.dprint(thing,None)
            return None
        # Check dynamic conditions
        for id,valid in self.conditions:
            if id==thing[l-1]:
                if l not in valid:
                    self.dprint(thing,False)
                    return False
        # Check base conditions (fixed or linked)
        option = self.options['names'].get(thing[l-1])
        if option.get('fixed') and option.get('place') != l and self.options['places'][l] != thing[l-1]:
            self.dprint(thing,False)
            return False
        # Check base conditions linked
        for t in thing:
            option = self.options['names'].get(t)
            if option.get('linked'):
                idx = None
                for x in [ o for o in option.get('list') ]:
                    if idx == None:
                        if x in thing:
                            idx = thing.index(x)
                            continue
                        else:
                            # Wrong order for linked items
                            self.dprint(thing,False)
                            return False
                    else:
                        idx += 1

                    if idx >= l:
                        break
                    if x != thing[idx]:
                        self.dprint(thing,False)
                        return False
                   
        # if option.get('linked'):
        #     llist = option.get('list')
        #     xlist = len(llist)
        #     a=l
        #     # Check that all linked elements are joined
        #     for x in range(llist.index(thing[l-1]),-1,-1):
        #         a-=1
        #         if a < 0:
        #             self.dprint(thing,False)
        #             return False
        #         if a >=0 and a < len(thing):
        #             if thing[a] != llist[x]:
        #                 self.dprint(thing,False)
        #                 return False
        #         else:
        #             print('ERROR BACKWARD')

        # If it's full, one solution was found
        if full:
            if self.debug_level > 0:
                self.debug_info['times'].append((self.stime,time()))
                self.stime = time()
            self.dprint(thing,True)
            # If self.complete, this is a exhaustive search with all results and need to continue recursion over the tree
            # If self.complete, results are stored
            self.results.append(thing)
            if self.complete:
                return None
            # If only need a first valid solution, return that solution ending recursion
            else:
                return thing
        # if not full, and not returned before, it's going well
        else:
            self.dprint(thing,None)
            return None

    # Reorder apply heuristic over possible recursion branches, improving time to answer and finding solution
    def reorder(self,used,possible):
        out = []
        level = len(used)
        # Try to use first whatever that has conditions applied and it's not used
        l=[elem for elem,places in self.conditions]
        for p in possible:
            if p in used:
                raise ValueError('Can\'t reorder {} because it\'s used and try to mark as possible'.format(p))
            if p not in l:
            # not conditionated elements insert at the end
                out.append(p)
            else:
                # conditionated elements first , try to get quickly fail or success
                for elem,places in self.conditions:
                    if p == elem:
                        if not len(places):
                            raise ValueError('Condition without candidate position')
                        if level in places:
                            out.insert(0,p)
                        else:
                            out.append(p)

                #             # try to insert at right position
                #             out.insert(places[0]-1,p)
                #         else:
                #             out.append(p)

        # BUT.... First LINKED elements
        # if used:
        #     if self.options['names'][used[-1]].get('linked'):
        #         linked_elements = self.options['names'][used[-1]].get('list')
        #         where = linked_elements.index(used[-1])
        #         for x in range(where+1,len(linked_elements)):
        #             out.remove(linked_elements[x])
        #             out.insert(0,self.options['names'][used[-1]].get('list')[x])
        
        # Assertion that list of possible elements for selecting next branch is the same reordered
        if len(possible) != len(out):
            print('Error')
            exit(1)
        return out

    # tree function makes recursive tree trying to find a valid combination
    # Parameters:
    # level: actual recursion level
    # used: combination used at this point of branch
    # initialcall: flag to identify if it's a recursive call or not, debugging purposes
    def tree(self,level=1,used='',initialcall=True):
        # Debugging counters for metrics
        if self.terminate:
            return
        if initialcall and self.debug_level > 0:
            self.stime = time()

        # Validate actual combination
        ret = self.validate(used)

        # If actual combination it's valid and it's partial solution (more elements need to be placed)
        if ret is None and level <= self.levels:
            # Check if this level has a fixed value specified from user selection
            if self.options['places'][level]:
                ret = self.tree(level+1,used+self.options['places'][level],False)
                if ret:
                    if initialcall and self.debug_level > 0:
                        self.debug_info['times'].append((self.stime,time()))
                    return ret
            # If this level(position) hasn't fixed value, need to run exhaustive recursion tree over actual combination
            else:
                possible = []
                if used and self.options['names'][used[-1]]['linked']:
                    l = self.options['names'][used[-1]]['list']
                    possible = [ o for o in l if o not in used ]
                if len(possible) == 0:
                    # possible values are: whatever element if not used until now and not fixed on any position,
                    possible = [ o for o in self.options['names'] if o not in used and o not in self.options['places'] ]
                    # optimize order of branches, selecting more probable branch first
                    possible = self.reorder(used,possible)
                # launch recursion tree
                for x in possible:
                    ret = self.tree(level+1,used + x,False)
                    # if returns combination(string), one value was found (evaluated as True), ends recursion
                    # if returns False, wrong value (evaluated as False), continue recursion
                    # if returns None, partial good result, continue recursion
                    if ret:
                        if initialcall and self.debug_level > 0:
                            self.debug_info['times'].append((self.stime,time()))
                        return ret
        # validation was failed or result is found
        else:
            if initialcall and self.debug_level > 0:
                self.debug_info['times'].append((self.stime,time()))
            return ret

        # validation evaluates good result until now
        if initialcall and self.debug_level > 0:
            self.debug_info['times'].append((self.stime,time()))

    # Initialize resolver structures
    # Parameter:
    # thing: string representation of table and user base conditions (fixed or linked)
    # Example) 
    #   - Each row is represented with two values (first (fixed), second (linked))
    #   - Each value is: (1 (true) or 0 (false))
    #
    #   Example table with 4 rows, first fixed, second normal, three an fouth linked
    #   thing = '10000101' or something as '10 00 01 01' or '10-00-01-01'...
    def initialize(self,thing):
        # Parse non desired characters (only 1 and 0)
        try:
            skip_characters = [x for x in thing if x not in '01' ]
            for x in skip_characters:
                thing = thing.replace(x,'')
        except:
            pass
        l = len(thing)
        # not empty thing and with odd values it's needed
        wellformed = l%2 == 0 and l!=0
        if not wellformed: 
            return False
        else:
            self.thing = thing
        # dynamic conditions for asking questions
        self.conditions = []
        self.combination = ''
        # options: stores table representation and characteristics or properties,
        #  'places' are fixed positions selected by the user,
        #  'names' are each row properties
        self.options = { 'places': {} , 'names': {} }
        
        # levels configures height of expansion tree of possible options into recursive calls
        # levels it's a number of rows from table
        self.levels = int(len(thing)/2)
        templinked = []
        fixedlist=False

        #if self.debug_level > 1:
        #    table = '--- TABLE ---\n'
        for i in range(self.levels):
            # each row has a string representation of one ascii character, example: three rows -> ABC
            name = chr(65+i)
            self.combination += name
            mark_fixed = thing[2*i]
            mark_linked = thing[2*i+1]
            #if self.debug_level > 1:
            #    table += '{}   | {} | {} |\n'.format(name,mark_fixed,mark_linked) 

            # built structure stores:
            #  actual position (place): int
            #  it's mark as fixed by user (ownfixed): bool
            #  it's mark as linked by user (linked): bool
            #  list of all linked group elements (list): list(int)
            #  flag if it's part of linked elements that are fixed, because any or all elements was mark as fixed by user (fixedlist): bool
            #  flag if it's fixed by any reason (fixed by user (ownfixed) or linked with some other that is fixed by user): bool (performs OR operation over 'ownfixed' and 'list' searching 'ownfixed')
            self.options['names'].setdefault(name,{'place':i+1,'ownfixed':mark_fixed=='1','linked':mark_linked=='1','list':[],'fixedlist':None,'fixed':None})
            
            # Complete structure iterating over linked elements
            if self.options['names'].get(name).get('linked'):
                templinked.append(name)
            else:
                for char in templinked:
                    if self.options['names'][char]['ownfixed']:
                        fixedlist = True
                    self.options['names'][char]['list']=templinked
                if fixedlist:
                    for char in templinked:
                        self.options['names'][char]['fixedlist'] = True
                templinked = []
                fixedlist = False
        #if self.debug_level > 1:
        #    table += '-------------\n'
        #    print(Color.makecolor(table,Color.YELLOW)
        
        # Complete structure iterating over linked elements
        # (this code is for last element not covered into loop)
        if templinked:
            for char in templinked:
                self.options['names'][char]['list']=templinked
                if self.options['names'][char]['ownfixed']:
                    fixedlist = True
            if fixedlist:
                    for char in templinked:
                        self.options['names'][char]['fixedlist'] = True
            templinked = False
            fixedlist = False
        for char in self.options['names']:
            self.options['names'][char]['fixed'] = self.options['names'][char]['ownfixed'] or self.options['names'][char]['fixedlist']
        
        # Build 'places' structure with fixed positions
        for i in range(self.levels):
            name = chr(65+i)
            if self.options['names'][name]['fixed']:
                self.options['places'][i+1] = name
            else:
                self.options['places'][i+1] = None
        
        return True

    # Get internal stored found results 
    def getResults(self):
        return self.results

    # function for debug recursion showing results
    def print_results(self):
        results = len(self.results)
        if not results:
            r = 'No solution'
        else:
            r = ','.join(self.results)
            if self.complete:
                r += ' ({} results)'.format(results)
            else:
                r += ' (first result)'
        if self.debug_level > 0:
            print(Color.makecolor(r,Color.BLUE))
        # Print metric counters
        self.print_debug_info()

# Class that make a cache over resolver improving speed with already called combinations
# This class it's needed cause resolver is called from update graphic functions from gui
#
# Cache stores results from resolver into dictionary, with key built with compound table state and conditions (queries + assertions from user)
class ResolverCached():
    cache = {}

    def __init__(self,*args,**kwargs):
        global DEBUG_LEVEL
        self.terminate = False
        self.debug_level = DEBUG_LEVEL
        self.fullreset()
    
    def abort(self):
        self.terminate = True
        self.resolver.abort()

    # get results from cache or run a recursive resolver
    def getResults(self,*args,**kwargs):
        if kwargs.get('debug'):
            global DEBUG_LEVEL
            DEBUG_LEVEL=2
            self.debug_level=2
            this_is_for_putting_debug_breakpoint_call_is_replaying=True
            # Remove key from cache
            del self.cache[self.makekey()]
        # get the cache key for current state
        k = self.makekey()
        if not k or not k in self.cache:
            # run expansion tree with resolver, when resolver ends, results are stored into cache
            self.tree()
        # return result from cache
        return self.cache[k]

    # Make a new resolver initialized
    def newQuery(self,*args,**kwargs):
        if not self.terminate:
            self.resolver = Resolver(*args,**kwargs)
            self.key = self.resolver.thing
            self.key_result = ''
            self.conditions = {}

    # Reset all
    def fullreset(self,*args,**kwargs):
        self.cache = {}
        self.key_result = ''
        self.conditions = {}

    # Reset conditions but not cached results
    def reset(self,*args,**kwargs):
        self.key_result = ''
        self.conditions = {}

    # Make a cache key built from table state and dynamic conditions
    # Parameters:
    # inserting: flag to set conditions into full resolver
    def makekey(self,inserting=False):
        self.key_result = self.key
        for t in sorted(list(self.conditions)):
            for d in sorted(list(self.conditions[t])):
                if inserting:
                    self.resolver.addCondition(t,d)
                self.key_result += str(t) + str(d)
        return self.key_result

    # Recursive call to run resolver if not exists one cached key
    def tree(self):
        # Calculates key
        if not self.terminate:
            k = self.makekey()
            if k not in self.cache:
                # Configure conditions into resolver
                k = self.makekey(inserting=True)
                # Run resolver
                self.resolver.tree()
                # Print results from resolver
                self.resolver.print_results()
                # Stores into cache the results
                self.cache[k] = self.resolver.getResults()
    
    # Stores dynamic conditions (queries) for running resolver
    # Need conditions (questions and tablestate) to query cache
    def addCondition(self, thing, dir):
        # Conditions (queries) are stored as dictionary keys
        # Example) Row 'B' need to go down -> we are querying if B can go down -> { 'B' : { 1 : {} } }
        self.conditions.setdefault(thing,{})
        self.conditions[thing].setdefault(dir,{})

    def get_row_value(self,state, row, column):
        FIXED_COLUMN = 0
        LINKED_COLUMN = 1
        try:
            return True if state[(row*2)+column] == '1' else False
        except:
            return False
    def row_is_linked(self, state, row):
        LINKED_COLUMN = 1
        return self.get_row_value(state,row,LINKED_COLUMN)
    def row_is_fixed(self, state, row):
        FIXED_COLUMN = 0
        return self.get_row_value(state,row,FIXED_COLUMN)

    def configureResolver(self, state, row, direction):
        ROW_COUNT = int(len(state)/2)

        # row to id representing row into resolver
        ID = chr(65+row)
        
        # starts new cachedresolver for query state & conditions
        self.newQuery(thing = state, complete = False, debug_level = self.debug_level)
        # add query (as condition) to get answer if one row can move or not
        self.addCondition(ID,direction)

        #
        # Optimization conditions (specially going up, because going down recursion is easiest)
        #
        # If query if one row can go up, maybe down rows can be fixed
        if direction == Direction.UP:
            # rows fixed for optimization
            s = ''
            # row pointer
            r = row
            # count bottom linked rows
            count=0
            # count down rows that are linked
            for i in range(r-1,-1,-1):
                if self.row_is_linked(state,i) and not self.row_is_fixed(state,i):
                    count+=1
            # move row pointer to end linked element (if current ID it's linked)
            while r < ROW_COUNT and self.row_is_linked(state,r):
                r += 1
            # move row pointer to allow down row linked elements going up
            while r < ROW_COUNT and count > 0 and not self.row_is_linked(state,r) and not self.row_is_fixed(state,r):
                r += 1
                count-=1
            # build condition for remaning rows
            for i in range(r,ROW_COUNT):
                s += chr(65+i)
            # remove current row to avoid duplicate condition on selected row
            s = s.replace(ID,'')
            # add optimization conditions
            if s:
                self.addCondition(s,Direction.FIXED.value)
        # If query if one row can go down, maybe up rows can be fixed
        if direction == Direction.DOWN:
            # rows fixed for optimization
            s = ''
            # row pointer
            r = row
            # count upper linked rows
            count = 0
            # count upper rows that are linked
            for i in range(r+1,ROW_COUNT):
                if self.row_is_linked(state,i) and not self.row_is_fixed(state,i):
                    count+=1
            # move row pointer to first element linked if ID it's linked
            while r > -1 and self.row_is_linked(state,r):
                r -= 1
            # move row pointer to allow upper elements go down
            while r > -1 and count > 0 and not self.row_is_linked(state,r) and not self.row_is_fixed(state,r):
                r -= 1
                count-=1
            # build condition for remaning rows
            for i in range(r,-1,-1):
                s = chr(65+i)+s
            # remove current row to avoid duplicate condition on selected row
            s = s.replace(ID,'')
            # add optimization conditions
            if s:
                self.addCondition(s,Direction.FIXED.value)

# COMENTED SINGLE CALLS TO RESOLVER
# COPIED FROM RESOLVER PYTHON DEVELOPED FILE
#
# if __name__ == "__main__":
# 	debug_level = 0
# 	complete = False
# 	resolver = Resolver(thing = Resolver.testclass.A, complete = complete, debug_level = debug_level)
# 	resolver.addCondition('A',Resolver.direction.DOWN)
# 	resolver.tree()
# 	print(resolver.getResults())
# 	resolver.print_results()
    
# 	print('With resolver')
# 	resolver = ResolverCached()
# 	resolver.newQuery(thing = Resolver.testclass.A, complete = complete, debug_level = debug_level)
# 	resolver.addCondition('A',Resolver.direction.DOWN)
# 	print(resolver.getResults())
# 	resolver.newQuery(thing = Resolver.testclass.A, complete = complete, debug_level = debug_level)
# 	resolver.addCondition('B',Resolver.direction.DOWN)
# 	print(resolver.getResults())
# 	resolver.newQuery(thing = Resolver.testclass.A, complete = complete, debug_level = debug_level)
# 	resolver.addCondition('A',Resolver.direction.DOWN)
# 	print(resolver.getResults())
# 	exit(0)

class BuildPersistentCache():
    def __init__(self):
        r = ResolverCached()
    
from queue import Queue

class Worker (QRunnable):
    #start = Signal()
    #stop = Signal()

    def __init__(self,parent,id):
        super().__init__()
        self.parent = parent
        self.id = id
        self.daemon = True
        self.joblist = parent.jobs
        self.model = parent.model
        self.resolver = ResolverCached()
        self.terminate = False
        #self.start()
        #self.start.connect(self.run)
        #self.stop.connect(self.stopRequested)

    @Slot()
    def stopRequested(self):
        self.terminate = True
        self.resolver.abort()

    @Slot()
    def run(self):
        while not self.parent.terminate:
            state,row,direction = self.joblist.get()
            print('Running worker {}'.format(self.id))
            self.resolver.configureResolver(state,row,direction)
            stime = time()
            R = self.resolver.getResults()
            duration = "{0:4.2f}".format(time() - stime)
            flagdirection = True if R else False
            result = R[0] if R else []
            self.parent.model[row][direction] = flagdirection
            self.parent.model[row][self.parent.modelStateOffset+direction] = True
            self.parent.model[row][self.parent.modelResultOffset+direction] = result
            print('End worker {} --> {} [ {} ]'.format(self.id,R,duration))
            self.parent.newResult.emit(row,direction,R)
            self.joblist.task_done()


class UpdatePool(QObject):
    newResult = Signal(int,int,str)
    modelItemSize = 6
    modelStateOffset = 2
    modelResultOffset = 4
    def __init__(self,parent):
        QObject.__init__(self)
        self.parent = parent
        global NUM_THREADS
        self.jobs = Queue(NUM_THREADS)
        self.workers = []
        self.threads = []
        # Model for movements list of rows, row with (upstate,downstate,updatestate)
        self.model = []
        self.stateString = ''
        self.levels = 0
        self.newResult.connect(self.newResultCompleted)
        self.threadpool = QThreadPool.globalInstance()
        self.threadpool.setMaxThreadCount(NUM_THREADS)
        self.terminate = False
        for w in range(1,NUM_THREADS+1):
            print("{}Initializing worker {}".format('\r'*50,w),end='')
            # worker = Worker(self,w)
            # self.workers.append(worker)
            # thread = QThread()
            # #thread.started.connect()
            # #thread.finished.connect()
            # worker.moveToThread(thread)
            # self.threads.append(thread)
            # thread.start()
            worker = Worker(self,w)
            self.workers.append(worker)
            self.threadpool.start(worker)
        print('')
    
    @Slot(int,int,str)
    def newResultCompleted(self,row,dir,result):
        self.parent.newResultCompleted(row,dir,result)

    def abort(self):
        for x in self.workers:
            x.stopRequested()
        self.threadpool.cancel()
        
    def set_stateString(self,stateString):
        if stateString != self.stateString:
            self.stateString = stateString
            self.levels = int(len(stateString)/2)
            self.invalidate_model()

    def invalidate_model(self):
        self.model = []
        self.model.append([0,1,True,False,None,None])
        for x in range(1,self.levels-1):
            self.model.append([1,1,False,False,None,None])
        self.model.append([1,0,False,True,None,None])
        for row in range(self.levels):
            if row==0:
                self.jobs.put((self.stateString,row,Direction.DOWN.value))
            elif row==self.levels:
                self.jobs.put((self.stateString,row,Direction.UP.value))
            else:
                self.jobs.put((self.stateString,row,Direction.UP.value))
                self.jobs.put((self.stateString,row,Direction.DOWN.value))

    def get_model_dirstate(self,state,row,direction):
        if state != self.stateString:
            self.set_stateString(state)
        state = self.model[row][direction]
        valid = self.model[row][self.modelStateOffset+direction]
        if not valid:
            self.jobs.put((self.stateString,row,direction))
        return state
    def get_model_moveresult(self,state,row,direction):
        if state != self.stateString:
            self.set_stateString(state)
        state = self.model[row][self.modelStateOffset+direction]
        result = self.model[row][self.modelResultOffset+direction]
        if not state:
            self.jobs.put((self.stateString,row,direction))
            return None
        return [result]



#
#
#   START GUI PROGRAM WITH QT (pyside2)
#
#

# Function for debugging page printer configuration
def print_preview_data(preview):
    orientation = preview.orientation().name.decode()
    viewmode = preview.viewMode().name.decode()
    zoommode = preview.zoomMode().name.decode()
    currentPage = preview.currentPage()
    pagecount = preview.pageCount()
    qDebug("(Preview)  {} {} {} {}/{}".format(orientation, viewmode, zoommode, currentPage, pagecount))

def marginsToString(margins):
    return "{} {} {} {}".format(margins.left(),margins.top(),margins.right(),margins.bottom())

# Function for debugging printer configuration
def print_printer_data(printer):
    pr = printer.paperRect()
    layout = printer.pageLayout()
    margins = layout.margins()
    size = layout.pageSize().id().name.decode()
    units = layout.units().name.decode()
    qDebug("(Printer)  Rect: {}x{} Size: {} Margins: {} Unit: {}".format(pr.width(),pr.height(),size,marginsToString(margins),units))

# Function for debugging document configuration
def print_document_data(document):
    size = document.pageSize()
    qDebug('(document) Rect: {}x{}'.format(int(size.width()),int(size.height())))

# Helper with static functions helping qt gui actions
class Helper():
    def __init__(self):
        pass
    # Generates qtaction with custom parameters
    # Parameters:
    # name: name of qtaction action, must be provided
    # fn: trigger function, must be provided
    # data: static data (string) included into qtaction, optional
    # icon: Qicon or string (filename) for qtaction, optional
    # shortcut: QKeySecuence or string representing shortcut for qtaction, optional
    # tip: string helping describe qtaction when mouse is over, optional
    # parent: parent QtObject, optional
    # Returns: QtAction configured
    @staticmethod
    def genAction(name=None, fn=None, data=None, icon=None, shortcut=None, tip=None, parent=None):
        # name and callback function are mandatory
        if name and fn:
            if icon:
                if isinstance(icon,str):
                    icon = QIcon(icon)
                elif isinstance(icon,QIcon):
                    pass
                else:
                    icon = None
            # icon can be filename (string) or QIcon
            if icon:
                action = QAction(icon,name,parent)
            else:
                action = QAction(name,parent)
            
            # allow empty data included
            if data != None:
                action.setData(data)
            # allow empty shortcut
            if shortcut:
                if isinstance(shortcut,QKeySequence):
                    pass
                else:
                    try:
                        shortcut = QKeySequence(shortcut)
                    except:
                        shortcut = None
            if shortcut:
                action.setShortcuts(shortcut)
            
            # allow empty tip
            if tip and isinstance(tip,str):
                action.setStatusTip(tip)

            action.triggered.connect(fn)

            return action
        return None       

# Delegate class for questions table logic 
# Allows customize data representation from table model and customize action cells with custom widgets
class tableDrawer(QStyledItemDelegate):
    def __init__(self, helper):
        global DEBUG_LEVEL
        self.debug_level = DEBUG_LEVEL
        super().__init__()
        self.parent = helper
        self.iconFixed = QIcon(TESTICONFIXED)
        self.iconLinked = QIcon(TESTICONLINKED)
        self.icons = ["go-up.svg","go-down.svg"]
        self.widgets = []
        for i in self.icons:
            w = QPushButton()
            w.setIcon(QIcon(i))
            #w.setText("UP")
            #w.setToolButtonStyle(Qt.ToolButtonStyle.ToolButtonIconOnly)
            self.widgets.append(w)

    # POSSIBLE ACTIONS THAT CAN BE REIMPLEMENTED INTO DELEGATE CLASS FOR VIEW THE MODEL DATA OF TABLE
    # (commented, this functions are not needed in this program)

    #def createEditor(self, parent, option, index):
    #    qDebug("CREATE EDITOR")
    #    return super().createEditor(parent, option, index)
    #def setEditorData(self, editor, index):
    #    qDebug("SET EDITOR DATA")
    #    return super().setEditorData(editor, index)
    #def setModelData(self, editor, model, index):
    #    qDebug("SET MODEL DATA")
    #    return super().setModelData(editor, model, index)
    #def sizeHint(self, option, index):
    #    qDebug("SIZE HINT")
    #    return super().sizeHint(option, index)
    #def updateEditorGeometry(self, editor, option, index):
    #    qDebug("UPDATE EDITOR GEOMETRY")
    #    return super().updateEditorGeometry(editor, option, index)
    #def eventFilter(self, editor, event):
    #    handled = super().eventFilter(editor, event)
    #    qDebug("EVENT FILTER {} {} {}".format(editor, event, handled))
    #    return handled

    # Implementation for managing events into table
    def editorEvent(self, event, model, option, index):
        # Disable not click release events
        if event.type() != QEvent.MouseButtonRelease:
            return True
        
        column = index.column()
        # First column providing up and down movement for rows
        # Model doesn't contain anything for this column
        if column == 0:
            # check what button is pressed thinking on mind that first middle width is for upbutton, rest for downbutton
            offset = option.rect.width() / 2
            if event.x() > offset:
                go = 'DOWN'
                direction = Direction.DOWN.value
            else:
                go = 'UP'
                direction = Direction.UP.value
            # Call for a helper function that manages if cell can be enabled or disabled
            if self.parent.canMove(index,direction):
                # If button was enabled emit signal for movement
                self.parent.cellMoveClick.emit(index.row(),go)
            else:
                # Disable movement not emitting signal
                qDebug("Impossible movement")
            return True # Mark all events on column 0 handled
            # Events on column 0 ends here

        # Events for setting fixed and linked rows
        if column < 3:
            return True # Mark events on cols 1,2 as handled after emitting custom signal
            # Events on columns 1, 2 ends here

        # Column 3 (text) does not handle event here
        if column == 3:
            self.parent.editingQuestion.emit(index.row())
            return True

        return super().editorEvent(event, model, option, index) # same as return False

    # # Configure CachedResolver function
    # # Initializes call to resolver without resetting cache adding some optimization conditions
    # # Called from Delegated table class that update graphics
    # def configureResolver(self, index, direction):
    #     # current row updating graphics
    #     ROW = index.row()
    #     ROW_COUNT = index.model().rowCount()
    #     LINKED_COLUMN = self.parent.headerItemNames.index('linked')
    #     FIXED_COLUMN = self.parent.headerItemNames.index('fixed')

    #     # row to id representing row into resolver
    #     ID = chr(65+ROW)
    #     # state from cells for use with resolver
    #     STATE = self.parent.stateString
    #     # starts new cachedresolver for query state & conditions
    #     self.parent.resolver.newQuery(thing = STATE, complete = False, debug_level = self.debug_level)
    #     # add query (as condition) to get answer if one row can move or not
    #     self.parent.resolver.addCondition(ID,direction)

    #     #
    #     # Optimization conditions (specially going up, because going down recursion are easiest)
    #     #
    #     # If query if one row can go up, maybe down rows can be fixed
    #     if direction == Direction.UP:
    #         # rows fixed for optimization
    #         s = ''
    #         # row pointer
    #         r = ROW
    #         # count bottom linked rows
    #         count=0
    #         # count down rows that are linked
    #         for i in range(r-1,-1,-1):
    #             if index.sibling(i,LINKED_COLUMN).data(Qt.DisplayRole) and not index.sibling(i,FIXED_COLUMN).data(Qt.DisplayRole):
    #                 count+=1
    #         # move row pointer to end linked element (if current ID it's linked)
    #         while ROW < ROW_COUNT and index.sibling(ROW,LINKED_COLUMN).data(Qt.DisplayRole):
    #             ROW += 1
    #         # move row pointer to allow down row linked elements going up
    #         while ROW < ROW_COUNT and count > 0 and not index.sibling(ROW,LINKED_COLUMN).data(Qt.DisplayRole) and not index.sibling(ROW,FIXED_COLUMN).data(Qt.DisplayRole):
    #             ROW += 1
    #             count-=1
    #         # build condition for remaning rows
    #         for i in range(ROW,ROW_COUNT):
    #             s += chr(65+i)
    #         # remove current row to avoid duplicate condition on selected row
    #         s = s.replace(ID,'')
    #         # add optimization conditions
    #         if s:
    #             self.parent.resolver.addCondition(s,Direction.FIXED.value)
    #     # If query if one row can go down, maybe up rows can be fixed
    #     if direction == Direction.DOWN:
    #         # rows fixed for optimization
    #         s = ''
    #         # row pointer
    #         r = ROW
    #         # count upper linked rows
    #         count = 0
    #         # count upper rows that are linked
    #         for i in range(r+1,ROW_COUNT):
    #             if index.sibling(i,LINKED_COLUMN).data(Qt.DisplayRole) and not index.sibling(i,FIXED_COLUMN).data(Qt.DisplayRole):
    #                 count+=1
    #         # move row pointer to first element linked if ID it's linked
    #         while ROW > -1 and index.sibling(ROW,LINKED_COLUMN).data(Qt.DisplayRole):
    #             ROW -= 1
    #         # move row pointer to allow upper elements go down
    #         while ROW > -1 and count > 0 and not index.sibling(ROW,LINKED_COLUMN).data(Qt.DisplayRole) and not index.sibling(ROW,FIXED_COLUMN).data(Qt.DisplayRole):
    #             ROW -= 1
    #             count-=1
    #         # build condition for remaning rows
    #         for i in range(ROW,-1,-1):
    #             s = chr(65+i)+s
    #         # remove current row to avoid duplicate condition on selected row
    #         s = s.replace(ID,'')
    #         # add optimization conditions
    #         if s:
    #             self.parent.resolver.addCondition(s,Direction.FIXED.value)

    # Repaint function for question table
    def paint(self, painter, option, index):
        if not index.isValid():
            return
        #if option.state & QStyle.State_Enabled:
        #    qDebug("Painting because state enabled")
        #if option.state & QStyle.State_MouseOver:
        #    qDebug("Painting becaused state mouseover")
        
        CURRENT_COLUMN = index.column()
        ORDER_COLUMN = self.parent.headerItemNames.index('order')
        FIXED_COLUMN = self.parent.headerItemNames.index('fixed')
        LINKED_COLUMN = self.parent.headerItemNames.index('linked')
        QUESTION_COLUMN = self.parent.headerItemNames.index('question type')
        
        # First (0) column with movement buttons
        if CURRENT_COLUMN == ORDER_COLUMN:
            count = len(self.widgets)
            # split table cell for two button (up, down)
            size_available = option.rect.width() / count
            DIRECTION_IDX = 0
            for w in self.widgets:
                painter.save()
                ws = w.style()
                opt = QStyleOptionButton()
                opt.rect = option.rect.translated(DIRECTION_IDX*size_available,0)
                opt.rect.setWidth(size_available)
                #opt.text = "{}".format(DIRECTION_IDX)
                opt.icon = w.icon()
                #opt.iconSize = QSize(option.rect.height(),option.rect.height())

                # Set all button state
                if self.parent.canMove(index,DIRECTION_IDX):
                    opt.state = ws.State_Enabled
                else:
                    opt.state = ws.State_Off

                #QApplication.style().drawControl(ws.CE_PushButton,opt,painter,w)
                ws.drawControl(ws.CE_PushButton,opt,painter,w)
                painter.restore()
                DIRECTION_IDX += 1
        # Other cells are: fixed cell , linked cell, question string
        else:
            # set icon for cells 1 and 2
            if CURRENT_COLUMN == FIXED_COLUMN:
                col_icon = self.iconFixed
            if CURRENT_COLUMN == LINKED_COLUMN:
                col_icon = self.iconLinked
            # on model, cells 1 and 2 are represented with boolean data
            cellState = index.data(Qt.DisplayRole)
            if CURRENT_COLUMN != QUESTION_COLUMN:    
                if cellState == True:
                    option.icon = col_icon
                else:
                    option.icon = QIcon()
                option.text = ""
                option.decorationSize = QSize(option.rect.height(), option.rect.height())
                # Must to set position if alignment need to be setted
                option.decorationPosition = QStyleOptionViewItem.Top
                option.decorationAlignment = Qt.AlignCenter
            # cell 3 with question string and no icon
            else:
                option.icon = QIcon()
                option.text = cellState
            
            # draw native text widget or icon widget
            if option.text:
                #super().paint(painter, option, index)
                # same as next call
                option.widget.style().drawControl(QStyle.CE_ItemViewItem,option,painter,option.widget)
            if option.icon or index.data(Qt.DecorationRole):
                option.icon.paint(painter,option.rect,option.decorationAlignment,QIcon.Mode.Normal,QIcon.State.On)

# Class for helping related qt functions for table questions
class tableHelper(QObject):
    # Signals triggered from delegated class
    # Cellmoveclick trigger movement for any row
    cellMoveClick = Signal(int,str)
    # editingquestion trigger editor for cell string 
    editingQuestion = Signal(int)

    # class initialization with:
    #  table: qtablewidget view
    def __init__(self, table=None, parent=None):
        global DEBUG_LEVEL
        self.debug_level = DEBUG_LEVEL

        QObject.__init__(self)
        if parent:
            # link to parent as controller for calling functions, events or sending data back
            self.controller = parent

        if table:
            # initialize internal data with table data
            self.setTableView(table)
            # connect signals from table with local functions as callback
            self.cellMoveClick.connect(self.moveRow)
            # set delegate class for customizing view from model data
            self.delegate = tableDrawer(self)
            table.setItemDelegate(self.delegate)
        # local string representing table rows selection
        # this state represents number of rows, and state linked or fixed for each row
        self.stateString = ''
        # create new cachedresolver for query movements
        #self.resolver = ResolverCached()
        self.pool = UpdatePool(self)

    # initialize internal data from table provided and setup table for store and view questions
    # initialize callbacks for custom menu on cells
    # initialize callcacks for click on cells
    def setTableView(self, table):
        self.table = table
        # Maybe create own model in future
        # (model) QStandardItemModel(0,5)
        # (view) setModel(self.model)
        self.table.setColumnCount(5)
        self.model = table.model()
        # Last column is hidden, private data here
        self.table.setColumnHidden(self.table.columnCount()-1,True)
        self.configureHeader()
        self.table.setContextMenuPolicy(Qt.CustomContextMenu)
        self.table.customContextMenuRequested.connect(self.customMenu)
        self.table.cellClicked.connect(self.ClickOnCell)

    # Create header for tableview
    def configureHeader(self):
        self.headerItemNames = []
        header  = self.table.horizontalHeader()
        for i in range(self.table.columnCount()):
            item = self.table.horizontalHeaderItem(i)
            if item:
                header.setSectionResizeMode(i,QHeaderView.ResizeToContents)
                self.headerItemNames.append(str.lower(item.text()))
            else:
                self.headerItemNames.append("PRIVATE")
        self.table.horizontalHeader().setStretchLastSection(True)

    # Update internal statestring used by resolver
    # Need to update statestring when rows are modified
    def updateStateString(self):
        self.stateString = self.getStateString()
        #self.resolver.reset()
        self.pool.set_stateString(self.stateString)

    # build new state string representing table
    # two digit with value of 0 (disabled) or 1 (enabled) from each row, representing fixed and linked cells
    def getStateString(self):
        FIXED_COL = self.headerItemNames.index('fixed')
        LINKED_COL = self.headerItemNames.index('linked')
        NUM_COLS = self.model.columnCount()
        NUM_ROWS = self.model.rowCount()
        states = ''
        for y in range(NUM_ROWS):
            for x in [ FIXED_COL, LINKED_COL ]:
                states += '1' if self.model.data(self.model.index(y,x),Qt.DisplayRole) else '0'
        #if self.controller:
        #    self.controller.window.statusbar.showMessage("State = {}".format(states),10*1000)
        return states
    
    # call update graphics from native widget to update movement buttons
    def updateCellGraphics(self,rows='all',cols='all'):
        qDebug('Updating graphics for {} {}'.format(rows,cols))
        if rows == 'all':
            rows = list(range(self.model.rowCount()))
        if cols == 'all':
            cols = list(range(self.model.columnCount()))
        if not isinstance(rows,list) and not isinstance(cols,list):
            return
        for y in rows:
            for x in cols:
                self.table.update(self.model.index(y,x))
    
    # Callback from delegate class when click is done on cells linked (col 2) or fixed (col 1)
    @Slot(int, int)
    def ClickOnCell(self, row, column):
        #
        # Method manager for click linkable, lockable cells, no movement here
        #
        FIXED_COL = self.headerItemNames.index('fixed')
        LINKED_COL = self.headerItemNames.index('linked')

        if column not in [ FIXED_COL , LINKED_COL ]:
            return True
        
        FIRST_COL = 0 
        FIRST_ROW = 0
        NUM_COLS = self.model.columnCount()
        NUM_ROWS = self.model.rowCount()
        LAST_COL = NUM_COLS -1
        LAST_ROW = NUM_ROWS -1

        # if there isn't a minium of two rows, linked action isn't available
        if NUM_ROWS < 2 and column == LINKED_COL:
            return True

        # get cell state for a row and col
        def getCellState(row,col):
            return self.model.data(self.model.index(row,col),Qt.DisplayRole)
        # set cell state for a row and col
        def putCellState(row,col,state):
            self.model.setData(self.model.index(row,col),state,Qt.DisplayRole)
        # flip state for a row and col, support one or more rows and cols passing lists
        def flipCellState(rows,cols):
            if not isinstance(rows,list):
                rows = [ rows ]
            if not isinstance(cols,list):
                cols = [ cols ]
            invalidate = False
            for r in rows:
                for c in cols:
                    putCellState(r,c,not getCellState(r,c))
                    invalidate = True
            return invalidate
        # one alone row, can't be linked, minium linked rows are two
        # remove alone linked states
        def removeAloneLinks():
            remove_linked_rows = []
            if NUM_ROWS > 1:
                for r in range(FIRST_ROW,NUM_ROWS):
                    current_is_linked = getCellState(r,LINKED_COL)
                    next_is_linked = getCellState(r+1,LINKED_COL)
                    prev_is_linked = getCellState(r-1,LINKED_COL)
                    if r == FIRST_ROW and current_is_linked and not next_is_linked:
                        remove_linked_rows.append(r)
                        continue
                    if r == LAST_ROW and current_is_linked and not prev_is_linked:
                        remove_linked_rows.append(r)
                        continue
                    if current_is_linked and not next_is_linked and not prev_is_linked:
                        remove_linked_rows.append(r)
                        continue
            for r in remove_linked_rows:
                putCellState(r,LINKED_COL,False)

        columns = [ column ]
        rows = [ row ]
        # if click was on linked cell, link with next or previous cell
        # linked rows will be stored into list
        if column == LINKED_COL:
            CURRENT_STATE = getCellState(row,LINKED_COL)
            if CURRENT_STATE == False:
                # Links two rows on first linking
                if row == FIRST_ROW:
                    if row < LAST_ROW and not getCellState(row+1,LINKED_COL):
                        rows.append(row+1)
                else:
                    if row < LAST_ROW and not getCellState(row+1,LINKED_COL) and not getCellState(row-1,LINKED_COL):
                        rows.append(row+1)

        # Flip state for list of rows and cols
        if flipCellState(rows,columns):
            removeAloneLinks()
            self.updateStateString()
            self.updateCellGraphics(rows='all',cols=[self.headerItemNames.index('order')])
        return True

    # Build custom menu for each row
    @Slot(QPoint)
    def customMenu(self, position):
        item = self.table.itemAt(position)
        if not item:
            qDebug("No item on that position!")
            return
        qDebug("item on x:{} y:{} with value {}".format(item.column(),item.row(),item.text()))
        qm = QMenu('titulo', self.table)
        if item.column()!=0:
            for seq in range(1,4):
                qm.addAction(Helper.genAction(name="ContextAction{}_{}".format(seq,item.text()),fn=self.printContextAction,data="ContextAction_{}_Data".format(seq,item.text()),icon=TESTICON,shortcut=None,tip="TipContextAction_{}".format(seq,item.text()),parent=qm))
            qm.addAction(Helper.genAction(name="Delete line '{}'".format(item.text()),fn=self.deleteContextAction,data=item.row(),icon=TESTICON,shortcut=None,tip="TipContextAction_Delete_{}".format(item.text()),parent=qm))
        else:
            self.makeLinkedAction(item.row())
        qm.exec_(QCursor.pos())

    # Callback for print on statusbar action triggered from contextmenu
    @Slot()
    def printContextAction(self):
        data = self.sender().data()
        qDebug("senderData:{}".format(data))
        if self.controller:
            self.controller.window.statusbar.showMessage("Action from '{}' triggered".format(data),10*1000)

    # Callback for delete row action triggered from contextmenu
    @Slot()
    def deleteContextAction(self):
        data = self.sender().data()
        self.table.removeRow(data)
        self.updateStateString()
        if self.controller:
            self.controller.window.statusbar.showMessage("Deleted row {}".format(data),10*1000)

    def newResultCompleted(self,row,dir,result):
        qDebug('New result: {} {} {}'.format(row,dir,result))
        self.updateCellGraphics(rows=[row],cols=[dir])

    # Function called from editorevent manager
    # Check if one row can move up or down taking number, position and states of all rows
    def canMove(self, index, direction):
        if direction not in [Direction.UP.value,Direction.DOWN.value]:
            return False
        # current row searching movement
        ROW = index.row()
        # internal id for selected row
        ID = chr(65+ROW)

        ROW_COUNT = index.model().rowCount()
        LINKED_COLUMN = self.headerItemNames.index('linked')
        FIXED_COLUMN = self.headerItemNames.index('fixed')
        
        # First can't go up and Last can't go down
        if ROW == 0 and direction == Direction.UP:
            return False
        if ROW == ROW_COUNT -1 and direction == Direction.DOWN:
            return False
        # Fixed rows can't move
        if index.sibling(ROW,FIXED_COLUMN).data(Qt.DisplayRole):
            return False
        
        # Linked rows with any of them fixed , can't move
        if index.sibling(ROW,LINKED_COLUMN).data(Qt.DisplayRole):
            idx = ROW -1
            # search upward fixed row on linked group
            while idx > 0 and index.sibling(idx,LINKED_COLUMN).data(Qt.DisplayRole):
                if index.sibling(idx,FIXED_COLUMN).data(Qt.DisplayRole):
                    return False
                else:
                    idx -= 1
            # search downward fixed row on linked group
            idx = ROW +1
            while idx < ROW_COUNT and index.sibling(idx,LINKED_COLUMN).data(Qt.DisplayRole):
                if index.sibling(idx,FIXED_COLUMN).data(Qt.DisplayRole):
                    return False
                else:
                    idx += 1
        # Configure resolver for query if it's a possible movement (if there is a solution with movement applied)
        #self.configureResolver(index,direction)
        #self.resolver.configureResolver(self.stateString,ROW,direction)
        #self.pool.get_model_dirstate(self.stateString,ROW,direction)

        # debug timming counters
        stime = time()
        if self.debug_level > 0:
            print('{0:s} can move {1:s}? (Thinking...)'.format(ID,'DOWN' if direction else 'UP'))

        # Run cached resolver returning result
        # R = self.resolver.getResults()
        R = self.pool.get_model_dirstate(self.stateString,ROW,direction)

        duration = time() - stime
        if self.debug_level > 0:
            ipad = ''
            epad = ''
            if duration > 5.0:
                ipad = Color.RED.value
                epad = Color.RESET.value
            print('{0:s}{1:s} can move {2:s}? {3:s} [ {4:4.2f} secs ]{5:s}'.format(ipad,ID,'DOWN' if direction else 'UP','YES' if R else 'NO',duration,epad))
        
        global PAUSE_WHEN_SEEMS_WRONG
        if duration > 1.0 and PAUSE_WHEN_SEEMS_WRONG:
            pass
            #self.resolver.configureResolver(self.parent.stateString,ROW,direction)
            #R = self.resolver.getResults(debug=True)
        if duration > 0.05:
            print(duration)
        return True if R else False

    # Callback for move rows triggered from movement buttons on col 0
    # Impossible movements was filtered from delegate class rendering buttons
    # Impossible movements has disabled button that doesn't trigger signal through this callback
    # Parameters:
    # row: (int) number of row that wants to move
    # dir: (string) (UP or DOWN) with movement direction
    @Slot(int,str)
    def moveRow(self,row,dir):
        #
        # Method manager for row movement, impossible movements are filtered from table delegated class event manager
        #

        # Debug function printing model on terminal
        def printModel(m):
            print('MODEL')
            for y in range(0,m.rowCount()):
                s = []
                for x in range(1,m.columnCount()):
                    a=str(m.data(m.index(y,x),Qt.DisplayRole))
                    if a == 'None':
                        a=str(m.data(m.index(y,x),Qt.UserRole))
                    s.append(a)
                print('>{}{}: {}'.format('\t',y,' | '.join(s)))
        
        MODEL = self.table.model()
        # Change to integer for direction
        if dir == 'DOWN':
            dir = Direction.DOWN.value
        else:
            dir = Direction.UP.value

        # Need to get what row movement need to be done
        #self.delegate.configureResolver(MODEL.index(row,0),dir)
        #self.resolver.configureResolver(self.stateString,row,dir)

        # Results always will be available on cache otherwise action would be disabled
        #R = self.resolver.getResults()
        R = self.pool.get_model_moveresult(self.stateString,row,dir)
        # Change movements from sequence of chars to list of integers with new rows order
        if R:
            R = [ ord(x)-65 for x in R[0] ]
        else:
            self.controller.window.statusbar.showMessage("Thinking... please wait",10*1000)
            return

        # Emit signal while model are changing
        MODEL.layoutAboutToBeChanged.emit()
        # REORDER ROWS TO GET THE SAME ORDER AS ONE RETURNED FROM RESOLVER
        y = -1
        NUM_COLS = MODEL.columnCount()
        NUM_ROWS = MODEL.rowCount()
        done = False
        dest = -1
        while not done:
            changed = False
            dest+=1
            for dest in range(dest,NUM_ROWS):
                if dest != R[dest]:
                    # change rows
                    if self.debug_level > 1:
                        print('CHANGING {} <-> {}'.format(dest,R[dest]))
                        printModel(MODEL)
                    for x in range(1,NUM_COLS):
                        tmp = self.table.takeItem(dest,x)
                        self.table.setItem(dest,x,self.table.takeItem(R[dest],x))
                        self.table.setItem(R[dest],x,tmp)
                    if self.debug_level > 1:
                        printModel(MODEL)

                    # Each model movement must reorder state of result list while ordering for get updated row positions
                    R[R.index(dest)] = R[dest]
                    R[dest] = dest
                    changed = True
            done = not changed

        # Ending with an update of table state
        self.updateStateString()
        # Send signal of end model modification
        MODEL.layoutChanged.emit()
        return

    # Method for create and insert new row triggered for action bar or menu
    def makeRow(self, item="", table=None):
        if table is None and self.table is not None:
            table = self.table
        last_row = table.rowCount()
        table.insertRow(last_row)
        # Columns 1,2,3 alignment & size is set from delegated class
        #table.setItem(last_row,0,QTableWidgetItem())

        for col in [1,2]:
            idx=self.model.index(last_row,col)
            self.model.setData(idx,False,Qt.DisplayRole)

        # i = QTableWidgetItem("{}".format(item))
        # i.setTextAlignment(Qt.AlignLeft | Qt.AlignVCenter)
        # table.setItem(last_row,3,i)
        self.model.setData(self.model.index(last_row,3),"{}".format(item))

        col = self.model.columnCount() -1
        idx=self.model.index(last_row,col)
        # Store as UserRole into hidden column
        self.model.setData(idx,"{}".format(QUuid.createUuid().toString()),Qt.UserRole)

    def addItem(self, item):
        if item and isinstance(item,list):
            for i in item:
                self.addItem(i)
        else:
            self.makeRow(item)
            self.updateStateString()

# class for pdf preview object
class previewPrinter(QPrintPreviewDialog):
    toolbar = None
    actions = None

    def __init__(self, parent=None, printer=None):
        if parent is not None:
            self.parent = parent
        super().__init__(printer)
        self.preview = self.findChild(QPrintPreviewWidget)
        #self.toolbar = self.findChild(QToolBar)
        #self.actions = { a.iconText() : a for a in self.toolbar.actions() if (type(a) == type(QAction()) and a.isVisible()) and not a.isSeparator() }
        self.setupButtons()
    
    def setupButtons(self):
        self.preview.previewChanged.connect(self.previewChanged)

    @Slot()
    def previewChanged(self):
        qDebug("***** Preview changed! *****")
        print_preview_data(self.preview)
        print_printer_data(self.parent.printer)

# Helper class with pdf stuff related things
class helperPDF():

    header_table_cols = 3
    header_table_rows = 2

    def __init__(self, parent=None):
        self.parent = parent
        self.pageMargins = QMarginsF(10,10,10,10)
        self.orientation = QPageLayout.Orientation.Portrait
        self.layout = None
        self.printer = None
        self.resolution = QPrinter.HighResolution
        self.constPaperScreen = None
        self.document = None
        self.cursor = None
        self.styles = None
        self.widget = None
        self.printer, self.resolution, self.constPaperScreen, self.layout = self.initPrinter(printer=self.printer, resolution=self.resolution, margins=self.pageMargins, orientation=self.orientation)
        self.widget = self.initWidget(parent=self, printer=self.printer)
        pass

    def initPrinter(self, printer=None, resolution=QPrinter.HighResolution, margins=None, orientation=None):
        
        if not resolution:
            if self.resolution:
                resolution = self.resolution
            else:
                resolution = QPrinter(QPrinter.HighResolution).resolution()
                self.resolution = resolution
        
        if isinstance(resolution,QPrinter.PrinterMode):
            default_printer = QPrinter(resolution)
            resolution = QPrinter(resolution).resolution()
        else:
            default_printer = QPrinter()
            default_printer.setResolution(resolution)
            
        if not printer:
            if self.printer:
                printer = self.printer
            else:
                self.printer = default_printer
                printer = default_printer

        if printer.resolution() != resolution:
            printer.setResolution(resolution)
        
        current_layout = self.printer.pageLayout()
        changed_layout = False
        if current_layout.units() != QPageLayout.Millimeter:
            current_layout.setUnits(QPageLayout.Millimeter)
            changed_layout = True

        if margins is not None and isinstance(margins,QMarginsF):
            qDebug("Setting margins to {}".format(marginsToString(margins)))
            current_layout.setMargins(margins)
            changed_layout = True
        else:
            self.pageMargins = current_layout.margins()
        
        if orientation is not None and isinstance(orientation, QPageLayout.Orientation):
            qDebug("Setting orientation to {}".format(orientation.name.decode()))
            current_layout.setOrientation(orientation)
            changed_layout = True

        if changed_layout:
            printer.setPageLayout(current_layout)

        PaperToScreen = int( resolution / QPrinter(QPrinter.ScreenResolution).resolution() )
        self.constPaperScreen = PaperToScreen
        qDebug("Setting constant: {}".format(int(self.constPaperScreen)))

        relTextToA4 = int(self.printer.pageSizeMM().width()/210.0)
        self.relTextToA4 = relTextToA4
        qDebug("Setting text multiplier size: {}".format(relTextToA4))

        return printer, resolution, PaperToScreen, current_layout

    def initDocument(self, printer=None, document=None):
        if not printer:
            printer = self.printer
        if not document:
            document = QTextDocument()
        if not self.document:
            self.document = document
        document.setPageSize(QSize(printer.pageRect().size()))
        self.initStyles()
        return document

    def initWidget(self, parent=None, printer=None):
        
        widget = previewPrinter(parent=parent,printer=printer)
        if not self.widget:
            self.widget = widget
        widget.paintRequested.connect(self.paintRequest)
        return widget 

    def openWidget(self):
        self.widget.exec_()

    def initStyles(self, styles=None):
        
        if not styles:
            styles = {}
            self.styles = styles

        if not 'header.table' in styles:
            styles.setdefault('header.table',QTextTableFormat())
        styles['header.table'].setBorderStyle(QTextTableFormat.BorderStyle_Solid)
        styles['header.table'].setBorder(1.0)
        styles['header.table'].setBorderBrush(QBrush(Qt.black,Qt.SolidPattern))
        styles['header.table'].setMargin(0.0)
        styles['header.table'].setCellSpacing(0.0)
        styles['header.table'].setCellPadding(10 * self.constPaperScreen)
        styles['header.table'].setColumnWidthConstraints([ QTextLength(QTextLength.PercentageLength, 95/self.header_table_cols) ] * self.header_table_cols)

        styles['centerH'] = QTextBlockFormat()
        styles['centerH'].setAlignment(Qt.AlignCenter)
        
        styles['centerV'] = QTextCharFormat()
        styles['centerV'].setVerticalAlignment(QTextCharFormat.VerticalAlignment.AlignMiddle)

        styles['text'] = QTextCharFormat()
        
        qDebug("Using text multiplier size: {}".format(int(self.relTextToA4)))
        styles['text'].setFont(QFont("Times",10 * self.constPaperScreen * self.relTextToA4))
        return styles


    @Slot(QPrinter)
    def paintRequest(self, printer=None):
        qDebug("***** Repaint Event ! *****")

        self.initPrinter(printer)
        self.document = self.initDocument(printer = self.printer)

        print_document_data(self.document)
        print_printer_data(printer)

        document = self.makeHeaderTable(self.document,self.styles['header.table'] )
        document.print_(printer)
        

    def makeHeaderTable(self, document, style, rows = header_table_rows, cols = header_table_cols, images = {'left':'college.png','center':'department.jpg'}):
        def setupCell(row=0,col=0):
            cell = table.cellAt(row,col)
            cursor = cell.firstCursorPosition()
            cursor.setBlockFormat(self.styles['centerH'])
            cell.setFormat(self.styles['centerV'])
            return cursor
        
        max_image_width = (document.pageSize() / cols).width()
        max_image_height = (document.pageSize() / 6).height() # no big headers!
        def imageResized(name):
            image = QImage(name)
            new_image_height = image.height() * max_image_width / image.width()
            image = image.scaled(max_image_width,new_image_height,Qt.KeepAspectRatio,Qt.SmoothTransformation)
            if image.height() > max_image_height:
                new_image_width = image.width() * max_image_height / image.height()
                image = image.scaled(new_image_width,max_image_height,Qt.KeepAspectRatio,Qt.SmoothTransformation)
            return image

        cursor = QTextCursor(document)

        table = cursor.insertTable(rows,cols,self.styles['header.table'])
        first_element_row = 1
        first_element_col = 0
        num_rows = 1
        num_cols = cols

        table.mergeCells(first_element_row,first_element_col,num_rows,num_cols)
    
        cursor = setupCell(0,0)
        cursor.insertImage(imageResized(images['left']))

        cursor = setupCell(0,1)
        cursor.insertImage(imageResized(images['center']))
    
        from random import randint
        a = randint(3,20)
        b = randint(3,20)

        cursor = setupCell(0,2)
        cursor.insertText("Lorem ipsum " * a, self.styles['text'])

        cursor = setupCell(1,0)
        cursor.insertText("Lorem ipsum " * b, self.styles['text'])

        return document

# Custom object for display content questions
class Box(QGroupBox):
    closedBox = Signal(str)
    button_space = 4
    button_size = 22

    def __init__(self,title=None,parent=None):
        self.id = str(id(self))
        super().__init__(title="{}-{}".format(title,self.id[-6:]),parent=parent)
        self.layout = QGridLayout(self)
        self.setLayout(self.layout)
        self.button = QPushButton(QIcon(ICONCLOSE),"",self)
        self.button.setFlat(True)
        self.button.setStyleSheet('border: none')
        self.button.setIconSize(QSize(self.button_size,self.button_size))
        self.button.resize(self.button_size,self.button_size)
        self.button.move(self.width()-self.button.width()-self.button_space,self.button_space)
        self.button.clicked.connect(self.closeBox)

    def getId(self):
        return self.id

    def getGrid(self):
        return self.layout

    def resizeEvent(self, event):
        self.button.move(self.width()-self.button.width()-self.button_space,self.button_space)
        super().resizeEvent(event)
    
    def addTo(self, on):
        on.addWidget(self)
        return self,self.layout

    Slot()
    def closeBox(self):
        self.closedBox.emit(self.id)

# Class with helper to manage grid content used for question contents
class gridHelper(QObject):
    def __init__(self, grid=None, parent=None):
        super().__init__()
        self.parent = parent
        self.grid = grid
        self.boxes = {}
        self.idbox = 0
        self.init(self.grid)

    def init(self, grid):
        for i in range(5):
            self.idbox += 1
            b = Box("Frame #{}".format(self.idbox))
            b.addTo(grid)
            b.closedBox.connect(self.closeBox)
            self.boxes.setdefault(b.getId(),b)
            self.addTitleEditor(b.getGrid())
        self.spacer = QSpacerItem(0,0,QSizePolicy.Fixed,QSizePolicy.Expanding)
        self.addToGrid(self.grid,self.spacer)

    Slot(str)
    def closeBox(self, uuid):
        qDebug("Closing {}".format(uuid))
        b = self.boxes.get(uuid,None)
        if b:
            del self.boxes[uuid]
            self.grid.removeWidget(b)
            b.deleteLater()
            if len(self.boxes) == 0:
                self.grid.removeItem(self.spacer)
                self.init(self.grid)
            self.grid.update()

    def addToGrid(self, on, what, x=None, y=None ):
        if y is None:
            y = on.rowCount()
        if x is None:
            for i in range(on.columnCount()):
                if on.itemAtPosition(y,i) is None:
                    x = i
                    break

        if isinstance(what,QWidget):
            on.addWidget(what,y,x)
            return
        if isinstance(what,QLayoutItem):
            on.addItem(what,y,x)
            return
        if isinstance(what,list):
            all_widget = True
            all_list = True
            for i in what:
                if not isinstance(i,QWidget):
                    all_widget = False
                if not isinstance(i,list):
                    all_list = False
            if all_widget:
                for i in what:
                    self.addToGrid(on,i)
            if all_list:
                all_widget = True
                for i in what:
                    for j in i:
                        if not isinstance(j,QWidget):
                            all_widget = False
                            break
                    if not all_widget:
                        break
                if not all_widget:
                    qDebug("Error")
                    return
                else:
                    offset_x=0
                    for i in what:
                        for j in i:
                            self.addToGrid(on,j,x+offset_x,y)
                            offset_x+=1
        return

    def addTitleEditor(self, on):
        label = QLabel("Title")
        textedit = QTextEdit()
        self.addToGrid(on,[[label,textedit]])
        

# Main class of application
class AppMainWindow(QApplication):
    def __init__(self):
        super().__init__([])
        self.menu = {}
        self.window = self.loadUi()
        self.window.show()
        self.addMenuItem(["one","two"],["some","other",["menuitem"]])
        self.bind_toolbar_actions()
        self.tableQuestions = tableHelper(self.window.tableWidgetQuestions, self)
        self.tableQuestions.editingQuestion.connect(self.editingQuestion)
        self.window.scrollAreaAnswers.setVerticalScrollBarPolicy( Qt.ScrollBarAlwaysOn )
        self.scroll = gridHelper(self.window.gridEdition, self)
        self.window.previewButton.clicked.connect(self.clickedPreview)
        self.sheet = None
        self.aboutToQuit.connect(self.exitting)

    @Slot()
    def exitting(self):
        qDebug("exitting")
        self.tableQuestions.pool.terminate = True
        self.tableQuestions.pool.abort()
        self.tableQuestions.pool.threadpool.clear()
        for x in self.tableQuestions.pool.workers:
            self.tableQuestions.pool.threadpool.cancel(x)

    @Slot(int)
    def editingQuestion(self, row):
        qDebug("Editing {}".format(row))

    @Slot(bool)
    def clickedPreview(self,checked):
        qDebug("Preview clicked!")
        if not self.sheet:
            self.sheet = helperPDF(parent=self)
        self.sheet.openWidget()

    def loadUi(self):
        ui_file = QFile("mainwindow.ui")
        ui_file.open(QFile.ReadOnly)
        ui_loader = QUiLoader(self)
        window = ui_loader.load(ui_file)
        ui_file.close()
        return window

    def bind_toolbar_actions(self):
        for action in dir(self.window):
            action_obj = getattr(self.window,action)
            if isinstance(action_obj,QAction):
                action_obj.setData(action_obj.text())
                action_obj.triggered.connect(self.test)

    @Slot()
    def test(self):
        data = self.sender().data()
        qDebug("senderData:{}".format(data))
        self.window.statusbar.showMessage("Action from '{}' triggered".format(data),10*1000)
        self.tableQuestions.addItem(data)
        pass

    def calculate_default_menubar_shortcut(self,name):
        used = []
        for item in self.menu:
            for character in item:
                if character in used:
                    continue
                else:
                    used.append(character)
                    break
        newname = ""
        done = False
        for character in name:
            if done or character in used:
                newname += character
            else:
                newname += "&" + character
                done = True

        return newname

    def addMenuItem(self, *args, **kwargs):
        for name in args:
            if isinstance(name,list):
                self.addMenuItem(*name)
                continue
            if not isinstance(name,str) or name in self.menu:
                continue
            name_with_shortcut = self.calculate_default_menubar_shortcut(name)
            self.menu.setdefault(name,[])
            self.menu[name].append(self.window.menubar.addMenu(name_with_shortcut))
            action = Helper.genAction(name=name,fn=self.test,icon=TESTICON,tip=name,parent=self.menu[name][0],data=name)
            self.menu[name][0].addAction(action)

# Starting point of execution
if __name__ == "__main__":
    QApplication.setAttribute(Qt.AA_ShareOpenGLContexts)
    app = AppMainWindow()
    sys.exit(app.exec_())
