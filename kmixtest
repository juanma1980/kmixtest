#!/usr/bin/env python3

# This Python file uses the following encoding: utf-8

import sys

from PySide2.QtCore import *
from PySide2.QtWidgets import *
from PySide2.QtGui import *
from PySide2.QtPrintSupport import *
from PySide2.QtUiTools import *
TESTICON="option.svg"
TESTICONLINKED="linked.svg"
TESTICONFIXED="fixed.svg"
ICONCLOSE="close.svg"
from sys import exit
from time import time

class Resolver:
    class direction:
        UP = 0
        DOWN = 1
        FIXED = 2
    class testclass:
        A = '00 00 10 11 01 10 00 01 01'
        # A 0 0
        # B 0 0
        # C 1 0
        # D 1 1
        # E 0 1
        # F 1 0
        # G 0 0
        # H 0 1
        # I 0 1
    class colors:
        HEADER = '\033[95m'
        OKBLUE = '\033[94m'
        OKGREEN = '\033[92m'
        WARNING = '\033[93m'
        FAIL = '\033[91m'
        ENDC = '\033[0m'
        BOLD = '\033[1m'
        UNDERLINE = '\033[4m'

    def dprint(self,msg,found):
        if self.debug_level < 2:
            return
        if not msg:
            msg = "<empty>"
        begin = self.colors.FAIL
        end = self.colors.ENDC
        if found is True:
            begin = self.colors.OKGREEN
        elif found is None:
            begin = self.colors.WARNING
        print(begin+msg+end)

    def __init__(self,*args,**kwargs):
        thing = kwargs.get('thing',None)
        complete = kwargs.get('complete',None)
        debug_level = kwargs.get('debug_level',None)
        for i,value in enumerate(args,1):
            if i == 1 and not thing:
                thing = value
            if i == 2 and not complete:
                complete = value
            if i == 3 and not debug_level:
                debug_level = value

        if not complete:
            complete = False
        if not debug_level:
            debug_level = 0
        self.thing = thing

        self.complete = complete

        self.debug_info = { 'counter' : {'partial':0,'full':0}, 'times' : [] }
        self.debug_level = debug_level
        
        self.combination = ''
        self.levels = 0
        self.options = {}
        self.results = []
        self.conditions = []
        if not self.initialize(self.thing):
            print(self.colors.FAIL+'Not valid'+self.colors.ENDC)
            exit(1)

    def print_debug_info(self):
        if self.debug_level > 0:
            acu = 0.0
            s = []
            for ini,end in self.debug_info['times']:
                cur = end-ini
                acu += cur
                s.append('{0:4.2f}'.format(cur))
            print("Checks: {0:10d}/{1:<10d} [ TOTAL {2:4.2f} seconds ] [{3:s}]".format(self.debug_info['counter']['partial'],self.debug_info['counter']['full'],acu,'+'.join(s)))

    def addCondition(self,item,dir):
        item_tmp = ''
        item_bkp = item
        item = item.upper()
        for i in item:
            if self.options['names'][i].get('linked'):
                linked_str = ''.join(self.options['names'][i].get('list'))
                if linked_str not in item_tmp:
                    item_tmp += linked_str
            else:
                item_tmp += i
        item = item_tmp
        i = self.combination.index(item)+1
        if dir == self.direction.FIXED:
            for x in item:
                self.conditions.append((x,[i]))
                i+=1
        elif dir == self.direction.UP:
            k=len(item)
            for x in item:
                k-=1
                l = list(range(1,i-k))
                l.reverse()
                self.conditions.append((x,l))
        elif dir == self.direction.DOWN:
            k=0
            for x in item:
                k+=1
                self.conditions.append((x,list(range(i+k,self.levels+1))))

    def validate(self,thing):
        l = len(thing)
        full = l == self.levels

        if self.debug_level > 0:
            if full:
                self.debug_info['counter']['full'] += 1
            else:
                self.debug_info['counter']['partial'] += 1

        if not thing:
            self.dprint(thing,None)
            return None
        for id,valid in self.conditions:
            if id==thing[l-1]:
                if l not in valid:
                    self.dprint(thing,False)
                    return False
        option = self.options['names'].get(thing[l-1])
        if option.get('fixed') and option.get('place') != l and self.options['places'][l] != thing[l-1]:
            self.dprint(thing,False)
            return False
        if option.get('linked'):
            llist = option.get('list')
            xlist = len(llist)
            a=l
            for x in range(llist.index(thing[l-1]),-1,-1):
                a-=1
                if a < 0:
                    self.dprint(thing,False)
                    return False
                if a >=0 and a < len(thing):
                    if thing[a] != llist[x]:
                        self.dprint(thing,False)
                        return False
                else:
                    print('ERROR BACKWARD')
        # for id,valid in self.conditions:
        #     if id==thing[l-1]:
        #         if l not in valid:
        #             self.dprint(thing,False)
        #             return False
        if full:
            if self.debug_level > 0:
                self.debug_info['times'].append((self.stime,time()))
                self.stime = time()
            self.dprint(thing,True)
            self.results.append(thing)
            if self.complete:
                return None
            else:
                return thing
        else:
            self.dprint(thing,None)
            return None

    def tree(self,level=1,used='',initialcall=True):
        if initialcall and self.debug_level > 0:
            self.stime = time()
        ret = self.validate(used)

        if ret is None and level <= self.levels:
            if self.options['places'][level]:
                ret = self.tree(level+1,used+self.options['places'][level],False)
                if ret:
                    if initialcall and self.debug_level > 0:
                        self.debug_info['times'].append((self.stime,time()))
                    return ret
            else:
                for x in [ o for o in self.options['names'] if o not in used and o not in self.options['places'] ]:
                    ret = self.tree(level+1,used + x,False)
                    if ret:
                        if initialcall and self.debug_level > 0:
                            self.debug_info['times'].append((self.stime,time()))
                        return ret
        else:
            if initialcall and self.debug_level > 0:
                self.debug_info['times'].append((self.stime,time()))
            return ret
        
        if initialcall and self.debug_level > 0:
            self.debug_info['times'].append((self.stime,time()))

    def initialize(self,thing):
        try:
            skip_characters = [x for x in thing if x not in '01' ]
            for x in skip_characters:
                thing = thing.replace(x,'')
        except:
            pass
        l = len(thing)
        wellformed = l%2 == 0 and l!=0
        if not wellformed: 
            return False
        else:
            self.thing = thing
        self.conditions = []
        self.combination = ''
        self.options = { 'places': {} , 'names': {} }
        
        self.levels = int(len(thing)/2)
        templinked = []
        fixedlist=False
        #if self.debug_level > 1:
        #    table = '--- TABLE ---\n'
        for i in range(self.levels):
            name = chr(65+i)
            self.combination += name
            mark_fixed = thing[2*i]
            mark_linked = thing[2*i+1]
            #if self.debug_level > 1:
            #    table += '{}   | {} | {} |\n'.format(name,mark_fixed,mark_linked) 
            self.options['names'].setdefault(name,{'place':i+1,'ownfixed':mark_fixed=='1','linked':mark_linked=='1','list':[],'fixedlist':None,'fixed':None})
            if self.options['names'].get(name).get('linked'):
                templinked.append(name)
            else:
                for char in templinked:
                    if self.options['names'][char]['ownfixed']:
                        fixedlist = True
                    self.options['names'][char]['list']=templinked
                if fixedlist:
                    for char in templinked:
                        self.options['names'][char]['fixedlist'] = True
                templinked = []
                fixedlist = False
        #if self.debug_level > 1:
        #    table += '-------------\n'
        #    print(self.colors.WARNING+table+self.colors.ENDC)
        if templinked:
            for char in templinked:
                self.options['names'][char]['list']=templinked
                if self.options['names'][char]['ownfixed']:
                    fixedlist = True
            if fixedlist:
                    for char in templinked:
                        self.options['names'][char]['fixedlist'] = True
            templinked = False
            fixedlist = False
        for char in self.options['names']:
            self.options['names'][char]['fixed'] = self.options['names'][char]['ownfixed'] or self.options['names'][char]['fixedlist']
        for i in range(self.levels):
            name = chr(65+i)
            if self.options['names'][name]['fixed']:
                self.options['places'][i+1] = name
            else:
                self.options['places'][i+1] = None
        if self.complete:
            results = []
        return True

    def getResults(self):
        return self.results

    def print_results(self):
        results = len(self.results)
        if not results:
            r = 'No solution'
        else:
            r = ','.join(self.results)
            if self.complete:
                r += ' ({} results)'.format(results)
            else:
                r += ' (first result)'
        if self.debug_level > 0:
            print(self.colors.OKBLUE+r+self.colors.ENDC)
        self.print_debug_info()

class ResolverCached():
    def __init__(self,*args,**kwargs):
        self.reset()
    
    def getResults(self,*args,**kwargs):
        k = self.makekey()
        if not k or not k in self.cache: # or not self.cache[k]:
            self.tree()
        return self.cache[k]

    def newQuery(self,*args,**kwargs):
        self.resolver = Resolver(*args,**kwargs)
        self.key = self.resolver.thing
        self.key_result = ''
        self.conditions = {}

    def reset(self,*args,**kwargs):
        self.cache = {}
        self.key_result = ''
        self.conditions = {}

    def makekey(self,inserting=False):
        self.key_result = self.key
        for t in sorted(list(self.conditions)):
            for d in sorted(list(self.conditions[t])):
                if inserting:
                    self.resolver.addCondition(t,d)
                self.key_result += str(t) + str(d)
        return self.key_result

    def tree(self):
        def run():
            k = self.makekey(inserting=True)
            self.resolver.tree()
            self.resolver.print_results()
            self.cache[k] = self.resolver.getResults()
        k = self.makekey()
        if k not in self.cache:
            run()
    
    def addCondition(self, thing, dir):
        self.conditions.setdefault(thing,{})
        self.conditions[thing].setdefault(dir,{})

# if __name__ == "__main__":
# 	debug_level = 0
# 	complete = False
# 	resolver = Resolver(thing = Resolver.testclass.A, complete = complete, debug_level = debug_level)
# 	resolver.addCondition('A',Resolver.direction.DOWN)
# 	resolver.tree()
# 	print(resolver.getResults())
# 	resolver.print_results()
    
# 	print('With resolver')
# 	resolver = ResolverCached()
# 	resolver.newQuery(thing = Resolver.testclass.A, complete = complete, debug_level = debug_level)
# 	resolver.addCondition('A',Resolver.direction.DOWN)
# 	print(resolver.getResults())
# 	resolver.newQuery(thing = Resolver.testclass.A, complete = complete, debug_level = debug_level)
# 	resolver.addCondition('B',Resolver.direction.DOWN)
# 	print(resolver.getResults())
# 	resolver.newQuery(thing = Resolver.testclass.A, complete = complete, debug_level = debug_level)
# 	resolver.addCondition('A',Resolver.direction.DOWN)
# 	print(resolver.getResults())
# 	exit(0)

def print_preview_data(preview):
    orientation = preview.orientation().name.decode()
    viewmode = preview.viewMode().name.decode()
    zoommode = preview.zoomMode().name.decode()
    currentPage = preview.currentPage()
    pagecount = preview.pageCount()
    qDebug("(Preview)  {} {} {} {}/{}".format(orientation, viewmode, zoommode, currentPage, pagecount))

def marginsToString(margins):
    return "{} {} {} {}".format(margins.left(),margins.top(),margins.right(),margins.bottom())

def print_printer_data(printer):
    pr = printer.paperRect()
    layout = printer.pageLayout()
    margins = layout.margins()
    size = layout.pageSize().id().name.decode()
    units = layout.units().name.decode()
    qDebug("(Printer)  Rect: {}x{} Size: {} Margins: {} Unit: {}".format(pr.width(),pr.height(),size,marginsToString(margins),units))

def print_document_data(document):
    size = document.pageSize()
    qDebug('(document) Rect: {}x{}'.format(int(size.width()),int(size.height())))

class Helper():
    def __init__(self):
        pass
    @staticmethod
    def genAction(name=None, fn=None, data=None, icon=None, shortcut=None, tip=None, parent=None):
        if name and fn:
            if icon:
                if isinstance(icon,str):
                    icon = QIcon(icon)
                elif isinstance(icon,QIcon):
                    pass
                else:
                    icon = None
            if icon:
                action = QAction(icon,name,parent)
            else:
                action = QAction(name,parent)
            
            if data != None:
                action.setData(data)

            if shortcut:
                if isinstance(shortcut,QKeySequence):
                    pass
                else:
                    try:
                        shortcut = QKeySequence(shortcut)
                    except:
                        shortcut = None
            if shortcut:
                action.setShortcuts(shortcut)
            
            if tip and isinstance(tip,str):
                action.setStatusTip(tip)

            action.triggered.connect(fn)

            return action
        return None       

class tableDrawer(QStyledItemDelegate):
    def __init__(self, helper):
        super().__init__()
        self.parent = helper
        self.iconFixed = QIcon(TESTICONFIXED)
        self.iconLinked = QIcon(TESTICONLINKED)
        self.icons = ["go-up.svg","go-down.svg"]
        self.widgets = []
        for i in self.icons:
            w = QPushButton()
            w.setIcon(QIcon(i))
            #w.setText("UP")
            #w.setToolButtonStyle(Qt.ToolButtonStyle.ToolButtonIconOnly)
            self.widgets.append(w)

    #def createEditor(self, parent, option, index):
    #    qDebug("CREATE EDITOR")
    #    return super().createEditor(parent, option, index)
    #def setEditorData(self, editor, index):
    #    qDebug("SET EDITOR DATA")
    #    return super().setEditorData(editor, index)
    #def setModelData(self, editor, model, index):
    #    qDebug("SET MODEL DATA")
    #    return super().setModelData(editor, model, index)
    #def sizeHint(self, option, index):
    #    qDebug("SIZE HINT")
    #    return super().sizeHint(option, index)
    #def updateEditorGeometry(self, editor, option, index):
    #    qDebug("UPDATE EDITOR GEOMETRY")
    #    return super().updateEditorGeometry(editor, option, index)
    #def eventFilter(self, editor, event):
    #    handled = super().eventFilter(editor, event)
    #    qDebug("EVENT FILTER {} {} {}".format(editor, event, handled))
    #    return handled

    def editorEvent(self, event, model, option, index):
        # Disable not click release events
        if event.type() != QEvent.MouseButtonRelease:
            return True
        
        column = index.column()
        UP = 0
        DOWN = 1
        if column == 0:
            offset = option.rect.width() / 2
            if event.x() > offset:
                go = 'DOWN'
                direction = DOWN
            else:
                go = 'UP'
                direction = UP
            if self.canMove(index,direction):
                self.parent.cellMoveClick.emit(index.row(),go)
            else:
                qDebug("Impossible movement")
            return True # Mark all events on column 0 handled
            # Events on column 0 ends here

        if column < 3:
            return True # Mark events on cols 1,2 as handled after emitting custom signal
            # Events on columns 1, 2 ends here

        # Column 3 (text) does not handle event here
        if column == 3:
            self.parent.editingQuestion.emit(index.row())
            return True

        return super().editorEvent(event, model, option, index) # same as return False

    def canMove(self, index, direction):
        UP = 0
        DOWN = 1
        FIXED = 2
        if direction not in [UP,DOWN]:
            return False
        #if index.row() == 0 and direction == UP:
        #    return False
        #if index.row() == index.model().rowCount()-1 and direction == DOWN:
        #    return False
        ROW = index.row()
        LINKED_COLUMN = self.parent.headerItemNames.index('linked')
        ID = chr(65+ROW)
        STATE = self.parent.stateString
        self.parent.resolver.newQuery(thing = STATE, complete = False, debug_level = 2)
        self.parent.resolver.addCondition(ID,direction)
        if direction == UP:
            s = ''
            while ROW < index.model().rowCount() and index.sibling(ROW+1,LINKED_COLUMN).data(Qt.DisplayRole):
                ROW += 1
            for i in range(ROW+1,index.model().rowCount()):
                s += chr(65+i)
            if s:
                self.parent.resolver.addCondition(s,FIXED)
        if direction == DOWN:
            s = ''
            while ROW > 0 and index.sibling(ROW-1,LINKED_COLUMN).data(Qt.DisplayRole):
                ROW -= 1
            for i in range(ROW-1,-1,-1):
                s = chr(65+i)+s
            if s:
                self.parent.resolver.addCondition(s,FIXED)
        stime = time()
        print('{0:s} can move {1:s}? (Thinking...)'.format(ID,'DOWN' if direction else 'UP'))
        R = self.parent.resolver.getResults()
        duration = time() - stime
        if duration > 5.0:
            print('{0:s} can move {1:s}? {2:s} [ {3:4.2f} secs ]'.format(ID,'DOWN' if direction else 'UP','YES' if R else 'NO',duration))
        return True if R else False

        # CURRENT_COLUMN = index.column()
        # CURRENT_ROW = index.row()
        # FIRST_COL = 0
        # FIRST_ROW = 0
        # NEXT_ROW = CURRENT_ROW +1
        # PREV_ROW = CURRENT_ROW -1
        # NUM_ROWS = index.model().rowCount()
        # LAST_ROW = NUM_ROWS -1
        
        # FIXED_COLUMN = self.parent.headerItemNames.index('fixed')
        # LINKED_COLUMN = self.parent.headerItemNames.index('linked')

        # def getCellState(row,col,index=index):
        #     return index.sibling(row,col).data(Qt.DisplayRole)
        # def allLocked(range_search,column):
        #     all_locked = True
        #     for i in range_search:
        #         if not getCellState(i,column):
        #             all_locked = False
        #             break
        #     return all_locked
        # def allDownLocked():
        #     r = range(NEXT_ROW,NUM_ROWS)
        #     return allLocked(r,FIXED_COLUMN)
        # def allDownLinked():
        #     r = range(NEXT_ROW,NUM_ROWS)
        #     return allLocked(r,LINKED_COLUMN)
        # def allUpLocked():
        #     r = range(PREV_ROW,-1,-1)
        #     return allLocked(r,FIXED_COLUMN)
        # def allUpLinked():
        #     r = range(PREV_ROW,-1,-1)
        #     return allLocked(r,LINKED_COLUMN)
        # def RowIsLinked(row):
        #     return getCellState(row,LINKED_COLUMN)
        # def RowIsLocked(row):
        #     return getCellState(row,FIXED_COLUMN)
        # def getLinkedRowGroup(row):
        #     rowgroup=[]
        #     if not RowIsLinked(row):
        #         return []
        #     else:
        #         rowgroup.append(row)
        #     if CURRENT_ROW > 0:
        #         for r in range(PREV_ROW,-1,-1):
        #             if RowIsLinked(r):
        #                 rowgroup.append(r)
        #             else:
        #                 break
        #     if CURRENT_ROW < NUM_ROWS:
        #         for r in range(NEXT_ROW,NUM_ROWS):
        #             if RowIsLinked(r):
        #                 rowgroup.append(r)
        #             else:
        #                 break
        #     return sorted(rowgroup)
        # def lastOfGroup(list_linked):
        #     return list_linked[-1]
        # def firstOfGroup(list_linked):
        #     return list_linked[0]
        # def anyLocked(list_linked):
        #     for i in list_linked:
        #         if RowIsLocked(i):
        #             return True
        #     return False

        # def freeRows():
        #     available = list(range(NUM_ROWS))
        #     for r in range(FIRST_ROW,NUM_ROWS):
        #         if r not in available:
        #             continue
        #         if RowIsLocked(r):
        #             available.remove(r)
        #         if RowIsLinked(r):
        #             g = getLinkedRowGroup(r)
        #             if anyLocked(g):
        #                 for i in g:
        #                     if i in available:
        #                         available.remove(i)
        #     return available
        # def consecutiveNotLocked(cells):
        #     i=0
        #     max=0
        #     for r in cells:
        #         if not RowIsLocked(r):
        #             i+=1
        #         else:
        #             i=0
        #         if i > max:
        #             max = i
        #     return max
        # def consecutiveNotLockedUp(fromrow):
        #     l=range(fromrow-1,-1,-1)
        #     return consecutiveNotLocked(l)
        # def consecutiveNotLockedDown(fromrow):
        #     l=range(fromrow+1,NUM_ROWS)
        #     return consecutiveNotLocked(l)

        # if getCellState(CURRENT_ROW,FIXED_COLUMN):
        #     return False

        # if direction == UP:
        #     if CURRENT_ROW == FIRST_ROW:
        #         return False
            
        #     if RowIsLinked(CURRENT_ROW):
        #         if RowIsLinked(PREV_ROW):
        #             return False
        #         lg = getLinkedRowGroup(CURRENT_ROW)
        #         if anyLocked(lg):
        #             return False
        #         if len(lg) > consecutiveNotLockedUp(firstOfGroup(lg)):
        #             return False
        #     else:
        #         if allUpLinked() and anyLocked(getLinkedRowGroup(PREV_ROW)):
        #             return False
            
        #     if allUpLocked():
        #         return False

        # if direction == DOWN: 
        #     if CURRENT_ROW == LAST_ROW:
        #         return False

        #     if RowIsLinked(CURRENT_ROW):
        #         if RowIsLinked(NEXT_ROW):
        #             return False
        #         lg = getLinkedRowGroup(CURRENT_ROW)
        #         if anyLocked(lg):
        #             return False
        #         if len(lg) > consecutiveNotLockedDown(lastOfGroup(lg)):
        #             return False
        #     else:
        #         if allDownLinked() and anyLocked(getLinkedRowGroup(NEXT_ROW)):
        #             return False

        #     if allDownLocked():
        #         return False
        
        # if len(freeRows()) < 2:
        #     return False
        # return True

    def paint(self, painter, option, index):
        if not index.isValid():
            return
        #if option.state & QStyle.State_Enabled:
        #    qDebug("Painting because state enabled")
        #if option.state & QStyle.State_MouseOver:
        #    qDebug("Painting becaused state mouseover")
        CURRENT_COLUMN = index.column()
        ORDER_COLUMN = self.parent.headerItemNames.index('order')
        FIXED_COLUMN = self.parent.headerItemNames.index('fixed')
        LINKED_COLUMN = self.parent.headerItemNames.index('linked')
        QUESTION_COLUMN = self.parent.headerItemNames.index('question type')
        if CURRENT_COLUMN == ORDER_COLUMN:
            count = len(self.widgets)
            size_available = option.rect.width() / count
            DIRECTION_IDX = 0
            for w in self.widgets:
                painter.save()
                ws = w.style()
                opt = QStyleOptionButton()
                opt.rect = option.rect.translated(DIRECTION_IDX*size_available,0)
                opt.rect.setWidth(size_available)
                #opt.text = "{}".format(DIRECTION_IDX)
                opt.icon = w.icon()
                #opt.iconSize = QSize(option.rect.height(),option.rect.height())

                # # Set all button state
                if self.canMove(index,DIRECTION_IDX):
                    opt.state = ws.State_Enabled
                else:
                    opt.state = ws.State_Off

                #QApplication.style().drawControl(ws.CE_PushButton,opt,painter,w)
                ws.drawControl(ws.CE_PushButton,opt,painter,w)
                painter.restore()
                DIRECTION_IDX += 1
        else:
            if CURRENT_COLUMN == FIXED_COLUMN:
                col_icon = self.iconFixed
            if CURRENT_COLUMN == LINKED_COLUMN:
                col_icon = self.iconLinked
            
            cellState = index.data(Qt.DisplayRole)
            if CURRENT_COLUMN != QUESTION_COLUMN:    
                if cellState == True:
                    option.icon = col_icon
                else:
                    option.icon = QIcon()
                option.text = ""
                option.decorationSize = QSize(option.rect.height(), option.rect.height())
                # Must to set position if alignment need to be setted
                option.decorationPosition = QStyleOptionViewItem.Top
                option.decorationAlignment = Qt.AlignCenter 
            else:
                option.icon = QIcon()
                option.text = cellState

            if option.text:
                #super().paint(painter, option, index)
                # same as next call
                option.widget.style().drawControl(QStyle.CE_ItemViewItem,option,painter,option.widget)
            if option.icon or index.data(Qt.DecorationRole):
                option.icon.paint(painter,option.rect,option.decorationAlignment,QIcon.Mode.Normal,QIcon.State.On)

class tableHelper(QObject):
    cellMoveClick = Signal(int,str)
    editingQuestion = Signal(int)

    def __init__(self, table=None, parent=None):
        QObject.__init__(self)
        if parent:
            self.controller = parent
        if table:
            self.setTableView(table)
            self.cellMoveClick.connect(self.moveRow)
            table.setItemDelegate(tableDrawer(self))
        self.resolver = ResolverCached()
        self.stateString = ''

    def setTableView(self, table):
        self.table = table
        # Maybe create own model in future
        # (model) QStandardItemModel(0,5)
        # (view) setModel(self.model)
        self.table.setColumnCount(5)
        self.model = table.model()
        # Last column is hidden, private data here
        self.table.setColumnHidden(self.table.columnCount()-1,True)
        self.configureHeader()
        self.table.setContextMenuPolicy(Qt.CustomContextMenu)
        self.table.customContextMenuRequested.connect(self.customMenu)
        self.table.cellClicked.connect(self.ClickOnCell)

    def configureHeader(self):
        self.headerItemNames = []
        header  = self.table.horizontalHeader()
        for i in range(self.table.columnCount()):
            item = self.table.horizontalHeaderItem(i)
            if item:
                header.setSectionResizeMode(i,QHeaderView.ResizeToContents)
                self.headerItemNames.append(str.lower(item.text()))
            else:
                self.headerItemNames.append("PRIVATE")
        self.table.horizontalHeader().setStretchLastSection(True)

    def getStateString(self):
        FIXED_COL = self.headerItemNames.index('fixed')
        LINKED_COL = self.headerItemNames.index('linked')
        NUM_COLS = self.model.columnCount()
        NUM_ROWS = self.model.rowCount()
        states = ''
        for y in range(NUM_ROWS):
            for x in [ FIXED_COL, LINKED_COL ]:
                states += '1' if self.model.data(self.model.index(y,x),Qt.DisplayRole) else '0'
        if self.controller:
            self.controller.window.statusbar.showMessage("State = {}".format(states),30*1000)
        return states
        
    @Slot(int, int)
    def ClickOnCell(self, row, column):
        #
        # Method manager for click linkable, lockable cells, no movement here
        #
        FIXED_COL = self.headerItemNames.index('fixed')
        LINKED_COL = self.headerItemNames.index('linked')

        if column not in [ FIXED_COL , LINKED_COL ]:
            return True
        
        FIRST_COL = 0 
        FIRST_ROW = 0
        NUM_COLS = self.model.columnCount()
        NUM_ROWS = self.model.rowCount()
        LAST_COL = NUM_COLS -1
        LAST_ROW = NUM_ROWS -1


        def updateCellGraphics():
            ORDER_COL = self.headerItemNames.index('order')
            for i in range(FIRST_ROW,NUM_ROWS):
                self.table.update(self.model.index(i,ORDER_COL))
        def getCellState(row,col):
            return self.model.data(self.model.index(row,col),Qt.DisplayRole)
        def putCellState(row,col,state):
            self.model.setData(self.model.index(row,col),state,Qt.DisplayRole)
        def flipCellState(rows,cols):
            if not isinstance(rows,list):
                rows = [ rows ]
            if not isinstance(cols,list):
                cols = [ cols ]
            invalidate = False
            for r in rows:
                for c in cols:
                    putCellState(r,c,not getCellState(r,c))
                    invalidate = True
            return invalidate
        def removeAloneLinks():
            remove_linked_rows = []
            if NUM_ROWS > 1:
                for r in range(FIRST_ROW,NUM_ROWS):
                    current_is_linked = getCellState(r,LINKED_COL)
                    next_is_linked = getCellState(r+1,LINKED_COL)
                    prev_is_linked = getCellState(r-1,LINKED_COL)
                    if r == FIRST_ROW and current_is_linked and not next_is_linked:
                        remove_linked_rows.append(r)
                        continue
                    if r == LAST_ROW and current_is_linked and not prev_is_linked:
                        remove_linked_rows.append(r)
                        continue
                    if current_is_linked and not next_is_linked and not prev_is_linked:
                        remove_linked_rows.append(r)
                        continue
            for r in remove_linked_rows:
                putCellState(r,LINKED_COL,False)

        columns = [ column ]
        rows = [ row ]
        
        if column == LINKED_COL:
            CURRENT_STATE = getCellState(row,LINKED_COL)
            if CURRENT_STATE == False:
                if row == FIRST_ROW:
                    if row < LAST_ROW and not getCellState(row+1,LINKED_COL):
                        rows.append(row+1)
                else:
                    if row < LAST_ROW and not getCellState(row+1,LINKED_COL) and not getCellState(row-1,LINKED_COL):
                        rows.append(row+1)

        if flipCellState(rows,columns):
            removeAloneLinks()
            updateCellGraphics()
            self.stateString = self.getStateString()
        return True

    @Slot(QPoint)
    def customMenu(self, position):
        item = self.table.itemAt(position)
        if not item:
            qDebug("No item on that position!")
            return
        qDebug("item on x:{} y:{} with value {}".format(item.column(),item.row(),item.text()))
        qm = QMenu('titulo', self.table)
        if item.column()!=0:
            for seq in range(1,4):
                qm.addAction(Helper.genAction(name="ContextAction{}_{}".format(seq,item.text()),fn=self.printContextAction,data="ContextAction_{}_Data".format(seq,item.text()),icon=TESTICON,shortcut=None,tip="TipContextAction_{}".format(seq,item.text()),parent=qm))
            qm.addAction(Helper.genAction(name="Delete line '{}'".format(item.text()),fn=self.deleteContextAction,data=item.row(),icon=TESTICON,shortcut=None,tip="TipContextAction_Delete_{}".format(item.text()),parent=qm))
        else:
            self.makeLinkedAction(item.row())
        qm.exec_(QCursor.pos())
    
    @Slot()
    def printContextAction(self):
        data = self.sender().data()
        qDebug("senderData:{}".format(data))
        if self.controller:
            self.controller.window.statusbar.showMessage("Action from '{}' triggered".format(data),10*1000)

    @Slot()
    def deleteContextAction(self):
        data = self.sender().data()
        self.table.removeRow(data)
        self.stateString = self.getStateString()
        if self.controller:
            self.controller.window.statusbar.showMessage("Deleted row {}".format(data),10*1000)

    @Slot(int,str)
    def moveRow(self,row,dir):
        #
        # Method manager for row movement, impossible movements are filtered from table delegated class event manager
        #
        qDebug('Disabled')
        return
        UP = 1
        DOWN = 0
        if dir == 'UP':
            dir = UP
        else:
            dir = DOWN
        MODEL = self.table.model()
        MODEL.layoutAboutToBeChanged.emit()
        CURRENT_ROW = row
        PREV_ROW = row -1
        NEXT_ROW = row +1
        FIXED_COLUMN = self.headerItemNames.index('fixed')
        LINKED_COLUMN = self.headerItemNames.index('linked')
        def NUM_COLS():
            return MODEL.columnCount()
        def NUM_ROWS():
            return MODEL.rowCount()
        def LAST_ROW():
            return NUM_ROWS()-1
        def LAST_COL():
            return NUM_COLS()-1
        PRIVATE_COLUMN = LAST_COL()
        def DATA(row,col,take=False):
            role = Qt.DisplayRole
            idx = MODEL.index(row,col)
            if col == LAST_COL():
                role = Qt.UserRole
            data = MODEL.data(idx,role)
            if take:
                MODEL.setData(idx,None)
            return data
        def PUTDATA(row,col,data):
            role = Qt.DisplayRole
            if col == PRIVATE_COLUMN:
                role = Qt.UserRole
            if col == 3:
                data = "JAJAJa"
            return MODEL.setData(MODEL.index(row,col),data,role)
        def TAKE(row,col):
            return DATA(row,col,True)
        def RowEmpty(row):
             if DATA(row,PRIVATE_COLUMN):
                 return False
             return True
        def RowIsLocked(row):
            return DATA(row,FIXED_COLUMN)
        def RowIsLinked(row):
            return DATA(row,LINKED_COLUMN)
        def getId(row):
            return DATA(CURRENT_ROW,PRIVATE_COLUMN)
        # def searchPositionId(id):
        #     for i in range(0,LAST_ROW()):
        #         if id == getId(i):
        #             return i
        def getLinkedRowGroup(row):
            rowgroup=[]
            if not RowIsLinked(row):
                return []
            else:
                rowgroup.append(row)
            
            for r in range(row-1,-1,-1):
                if RowIsLinked(r):
                    rowgroup.append(r)
                else:
                    break
        
            for r in range(row+1,NUM_ROWS()):
                if RowIsLinked(r):
                    rowgroup.append(r)
                else:
                    break
            return sorted(rowgroup)
        def anyLocked(linked_group):
            for r in linked_group:
                if RowIsLocked(r):
                    return True
            return False
        def firstOfGroup(linked_group):
            return linked_group[0]
        def lastOfGroup(linked_group):
            return linked_group[-1]
        # def searchPlace(rows,size):
        #     i=0
        #     last_start=None
        #     for r in rows:
        #         if not RowIsLocked(r):
        #             if not last_start:
        #                 last_start=r
        #             i+=1
        #         else:
        #             i=0
        #             last_start=None
        #         if i == size:
        #             return last_start
        #     qDebug("Error searching place")
        #     return None
        # def searchPlaceDown(fromrow,size):
        #     place = searchPlace(range(fromrow+1,NUM_ROWS()),size)
        #     return lastOfGroup(getLinkedRowGroup(place))+1
        # def searchPlaceUp(fromrow,size):
        #     place = searchPlace(range(fromrow-1,-1,-1),size)
        #     return firstOfGroup(getLinkedRowGroup(place))

        # Deprecated: Impossible movements aren't triggered
        #
        # if RowIsLocked(CURRENT_ROW):
        #    qDebug("Can't move locked cell")
        #    return
        def takeAllRowItems(row):
            items = []
            for x in range(0,NUM_COLS()):
                items.append(TAKE(row,x))
            return items
        self.k=None
        def putAllRowItems(row,items):
            x=0
            for i in items:
                if isinstance(i,bool):
                    self.k=items[x]
                else:
                    self.k=items[x]
                print('{} {}'.format(self.k,PUTDATA(row,x,self.k)))
                #print(PUTDATA(row,x,i))
                x+=1
        def extractFixedRows():
            fixed_rows = {}
            for y in range(0,NUM_ROWS()):
                if RowIsLocked(y):
                    fixed_rows.setdefault(y,takeAllRowItems(y))
                    continue
                if RowIsLinked(y):
                    if anyLocked(getLinkedRowGroup(y)):
                        fixed_rows.setdefault(y,takeAllRowItems(y))
            return fixed_rows
        def printTable():
            for y in range(NUM_ROWS()):
                str=''
                for x in range(1,3):
                    i=DATA(y,x)
                    if i:
                        str+=' {}'.format(i.data(Qt.DisplayRole))
                    else:
                        str+=' {}'.format(None)
                qDebug(str)
        def analyzeTable():
            for y in range(NUM_ROWS()):
                pass
        if RowIsLinked(CURRENT_ROW):
            CURRENT_LINKED=True
        else:
            CURRENT_LINKED=False
        current_id=getId(CURRENT_ROW)
        # Store fixed rows { num_row : [ QTableItem ] }
        fixed_rows = extractFixedRows()
        for y in fixed_rows:
            #self.table.insertRow(0)
            #self.table.removeRow(y)
            #self.table.insertRow(y)
            putAllRowItems(y,fixed_rows[y])
        MODEL.layoutChanged.emit()
        return
        # linked rows = [ ( num_row , [QTableItem] ),( num_row , [QTableItem] ) ]
        # group all linked rows = [ linked_rows , linked_rows ]
        def extractLinkedRows():
            groups = []
            for y in range(0,NUM_ROWS()):
                if RowIsLinked(y):
                    linked_rows = []
                    for r in getLinkedRowGroup(y):
                        linked_rows.append((r,takeAllRowItems(r)))
                    groups.append(linked_rows)
            return groups

        groups_linked = extractLinkedRows()

        def extractSingleRows():
            single_rows = {}
            for y in range(0,NUM_ROWS()):
                if not RowEmpty(y):
                    single_rows.setdefault(y,takeAllRowItems(y))
            return single_rows

        single_rows = extractSingleRows()
        sum_linked = 0
        for g in groups_linked:
            sum_linked += len(g)
        if NUM_ROWS() != len(single_rows) + len(fixed_rows) + sum_linked:
            qDebug("Error")
        #self.table.clearContents()
        #self.table.reset()
        #self.table.repaint()
        #self.table.setRowCount(0)

        #self.table.reset()
        #self.table.repaint()
        #if not CURRENT_LINKED:
            

        return
        # Locked cells can't be here trying to move
        # Only 2 cell types can be here, with no action or linked cell(without lock)

        linked_group = []
        if RowIsLinked(CURRENT_ROW):
            linked_group = getLinkedRowGroup(CURRENT_ROW)
            if dir == UP:
                place = searchPlaceUp(CURRENT_ROW,len(linked_group))
                # move all group up are the same as moving down previous cell before the group
                # groups with first and last rows, are blocked and can't be triggered
                moving_rows = []
                offset=0
                for x in linked_group:
                    moving_rows.append((x+offset*2,place+offset))
                    offset+=1
            else:
                place = searchPlaceDown(CURRENT_ROW,len(linked_group))
                # move all group down are the same as moving up next cell after the group
                # groups with first and last rows, are blocked and can't be triggered
                moving_rows = []
                offset=0
                for x in linked_group:
                    moving_rows.append((x+offset,place+offset))
                    offset+=1
                row = lastOfGroup(linked_group)+1
                onrow = firstOfGroup(linked_group)
        else: # Normal cell (without action), need to jump throught locked/linked cells
            # Remember row mem address to move (when relocating, needed row index is changed)
            first_of_row = self.table.item(CURRENT_ROW,0)
            the_id = id(self.table.item(CURRENT_ROW,0))
            for y in range(NUM_ROWS()):
                if RowIsLocked(y):
                    items = []
                    for x in range(NUM_COLS()):
                        items.append(self.table.takeItem(y,x))
                    fixed_rows.setdefault(y,items)
            # After store, remove rows 
            offset=0 # while removing rows top-bottom higher indexes are changing
            for y in sorted(fixed_rows):
                self.table.removeRow(y-offset)
                offset+=1
            # Update new position
            found = False # Make sure that element are found
            for y in range(NUM_ROWS()):
                newid = id(self.table.item(y,0))
                if newid == the_id:
                    qDebug("found")
                if self.table.item(y,0) is first_of_row:
                    row = y
                    found = True
                    break
            if not found:
                qDebug("Error searching element")
                return

            # Calculate origin and destination
            if dir == UP:
                onrow = row -1
            else:
                onrow = row +2
        
        # Insert moved row
        self.table.insertRow(onrow)
        # With insertion the indexes were modified
        if row > onrow:
            row += 1

        for col in range(NUM_COLS()):
            self.table.setItem(onrow,col,self.table.takeItem(row,col))
        self.table.removeRow(row)
        
        # Insert remaning fixed rows into his position
        for y in fixed_rows:
            self.table.insertRow(y)
            for x in range(NUM_COLS()):
                self.table.setItem(y,x,fixed_rows[y][x])

    def makeRow(self, item="", table=None):
        if table is None and self.table is not None:
            table = self.table
        last_row = table.rowCount()
        table.insertRow(last_row)
        # Columns 1,2,3 alignment & size is set from delegated class
        #table.setItem(last_row,0,QTableWidgetItem())

        for col in [1,2]:
            idx=self.model.index(last_row,col)
            self.model.setData(idx,False,Qt.DisplayRole)

        # i = QTableWidgetItem("{}".format(item))
        # i.setTextAlignment(Qt.AlignLeft | Qt.AlignVCenter)
        # table.setItem(last_row,3,i)
        self.model.setData(self.model.index(last_row,3),"{}".format(item))

        col = self.model.columnCount() -1
        idx=self.model.index(last_row,col)
        # Store as UserRole into hidden column
        self.model.setData(idx,"{}".format(QUuid.createUuid().toString()),Qt.UserRole)

    def addItem(self, item):
        if item and isinstance(item,list):
            for i in item:
                self.addItem(i)
        else:
            self.makeRow(item)
            self.stateString = self.getStateString()

class previewPrinter(QPrintPreviewDialog):
    toolbar = None
    actions = None

    def __init__(self, parent=None, printer=None):
        if parent is not None:
            self.parent = parent
        super().__init__(printer)
        self.preview = self.findChild(QPrintPreviewWidget)
        #self.toolbar = self.findChild(QToolBar)
        #self.actions = { a.iconText() : a for a in self.toolbar.actions() if (type(a) == type(QAction()) and a.isVisible()) and not a.isSeparator() }
        self.setupButtons()
    
    def setupButtons(self):
        self.preview.previewChanged.connect(self.previewChanged)

    @Slot()
    def previewChanged(self):
        qDebug("***** Preview changed! *****")
        print_preview_data(self.preview)
        print_printer_data(self.parent.printer)

class helperPDF():

    header_table_cols = 3
    header_table_rows = 2

    def __init__(self, parent=None):
        self.parent = parent
        self.pageMargins = QMarginsF(10,10,10,10)
        self.orientation = QPageLayout.Orientation.Portrait
        self.layout = None
        self.printer = None
        self.resolution = QPrinter.HighResolution
        self.constPaperScreen = None
        self.document = None
        self.cursor = None
        self.styles = None
        self.widget = None
        self.printer, self.resolution, self.constPaperScreen, self.layout = self.initPrinter(printer=self.printer, resolution=self.resolution, margins=self.pageMargins, orientation=self.orientation)
        self.widget = self.initWidget(parent=self, printer=self.printer)
        pass

    def initPrinter(self, printer=None, resolution=QPrinter.HighResolution, margins=None, orientation=None):
        
        if not resolution:
            if self.resolution:
                resolution = self.resolution
            else:
                resolution = QPrinter(QPrinter.HighResolution).resolution()
                self.resolution = resolution
        
        if isinstance(resolution,QPrinter.PrinterMode):
            default_printer = QPrinter(resolution)
            resolution = QPrinter(resolution).resolution()
        else:
            default_printer = QPrinter()
            default_printer.setResolution(resolution)
            
        if not printer:
            if self.printer:
                printer = self.printer
            else:
                self.printer = default_printer
                printer = default_printer

        if printer.resolution() != resolution:
            printer.setResolution(resolution)
        
        current_layout = self.printer.pageLayout()
        changed_layout = False
        if current_layout.units() != QPageLayout.Millimeter:
            current_layout.setUnits(QPageLayout.Millimeter)
            changed_layout = True

        if margins is not None and isinstance(margins,QMarginsF):
            qDebug("Setting margins to {}".format(marginsToString(margins)))
            current_layout.setMargins(margins)
            changed_layout = True
        else:
            self.pageMargins = current_layout.margins()
        
        if orientation is not None and isinstance(orientation, QPageLayout.Orientation):
            qDebug("Setting orientation to {}".format(orientation.name.decode()))
            current_layout.setOrientation(orientation)
            changed_layout = True

        if changed_layout:
            printer.setPageLayout(current_layout)

        PaperToScreen = int( resolution / QPrinter(QPrinter.ScreenResolution).resolution() )
        self.constPaperScreen = PaperToScreen
        qDebug("Setting constant: {}".format(int(self.constPaperScreen)))

        relTextToA4 = int(self.printer.pageSizeMM().width()/210.0)
        self.relTextToA4 = relTextToA4
        qDebug("Setting text multiplier size: {}".format(relTextToA4))

        return printer, resolution, PaperToScreen, current_layout

    def initDocument(self, printer=None, document=None):
        if not printer:
            printer = self.printer
        if not document:
            document = QTextDocument()
        if not self.document:
            self.document = document
        document.setPageSize(QSize(printer.pageRect().size()))
        self.initStyles()
        return document

    def initWidget(self, parent=None, printer=None):
        
        widget = previewPrinter(parent=parent,printer=printer)
        if not self.widget:
            self.widget = widget
        widget.paintRequested.connect(self.paintRequest)
        return widget 

    def openWidget(self):
        self.widget.exec_()

    def initStyles(self, styles=None):
        
        if not styles:
            styles = {}
            self.styles = styles

        if not 'header.table' in styles:
            styles.setdefault('header.table',QTextTableFormat())
        styles['header.table'].setBorderStyle(QTextTableFormat.BorderStyle_Solid)
        styles['header.table'].setBorder(1.0)
        styles['header.table'].setBorderBrush(QBrush(Qt.black,Qt.SolidPattern))
        styles['header.table'].setMargin(0.0)
        styles['header.table'].setCellSpacing(0.0)
        styles['header.table'].setCellPadding(10 * self.constPaperScreen)
        styles['header.table'].setColumnWidthConstraints([ QTextLength(QTextLength.PercentageLength, 95/self.header_table_cols) ] * self.header_table_cols)

        styles['centerH'] = QTextBlockFormat()
        styles['centerH'].setAlignment(Qt.AlignCenter)
        
        styles['centerV'] = QTextCharFormat()
        styles['centerV'].setVerticalAlignment(QTextCharFormat.VerticalAlignment.AlignMiddle)

        styles['text'] = QTextCharFormat()
        
        qDebug("Using text multiplier size: {}".format(int(self.relTextToA4)))
        styles['text'].setFont(QFont("Times",10 * self.constPaperScreen * self.relTextToA4))
        return styles


    @Slot(QPrinter)
    def paintRequest(self, printer=None):
        qDebug("***** Repaint Event ! *****")

        self.initPrinter(printer)
        self.document = self.initDocument(printer = self.printer)

        print_document_data(self.document)
        print_printer_data(printer)

        document = self.makeHeaderTable(self.document,self.styles['header.table'] )
        document.print_(printer)
        

    def makeHeaderTable(self, document, style, rows = header_table_rows, cols = header_table_cols, images = {'left':'college.png','center':'department.jpg'}):
        def setupCell(row=0,col=0):
            cell = table.cellAt(row,col)
            cursor = cell.firstCursorPosition()
            cursor.setBlockFormat(self.styles['centerH'])
            cell.setFormat(self.styles['centerV'])
            return cursor
        
        max_image_width = (document.pageSize() / cols).width()
        max_image_height = (document.pageSize() / 6).height() # no big headers!
        def imageResized(name):
            image = QImage(name)
            new_image_height = image.height() * max_image_width / image.width()
            image = image.scaled(max_image_width,new_image_height,Qt.KeepAspectRatio,Qt.SmoothTransformation)
            if image.height() > max_image_height:
                new_image_width = image.width() * max_image_height / image.height()
                image = image.scaled(new_image_width,max_image_height,Qt.KeepAspectRatio,Qt.SmoothTransformation)
            return image

        cursor = QTextCursor(document)

        table = cursor.insertTable(rows,cols,self.styles['header.table'])
        first_element_row = 1
        first_element_col = 0
        num_rows = 1
        num_cols = cols

        table.mergeCells(first_element_row,first_element_col,num_rows,num_cols)
    
        cursor = setupCell(0,0)
        cursor.insertImage(imageResized(images['left']))

        cursor = setupCell(0,1)
        cursor.insertImage(imageResized(images['center']))
    
        from random import randint
        a = randint(3,20)
        b = randint(3,20)

        cursor = setupCell(0,2)
        cursor.insertText("Lorem ipsum " * a, self.styles['text'])

        cursor = setupCell(1,0)
        cursor.insertText("Lorem ipsum " * b, self.styles['text'])

        return document

class Box(QGroupBox):
    closedBox = Signal(str)
    button_space = 4
    button_size = 22

    def __init__(self,title=None,parent=None):
        self.id = str(id(self))
        super().__init__(title="{}-{}".format(title,self.id[-6:]),parent=parent)
        self.layout = QGridLayout(self)
        self.setLayout(self.layout)
        self.button = QPushButton(QIcon(ICONCLOSE),"",self)
        self.button.setFlat(True)
        self.button.setStyleSheet('border: none')
        self.button.setIconSize(QSize(self.button_size,self.button_size))
        self.button.resize(self.button_size,self.button_size)
        self.button.move(self.width()-self.button.width()-self.button_space,self.button_space)
        self.button.clicked.connect(self.closeBox)

    def getId(self):
        return self.id

    def getGrid(self):
        return self.layout

    def resizeEvent(self, event):
        self.button.move(self.width()-self.button.width()-self.button_space,self.button_space)
        super().resizeEvent(event)
    
    def addTo(self, on):
        on.addWidget(self)
        return self,self.layout

    Slot()
    def closeBox(self):
        self.closedBox.emit(self.id)

class gridHelper(QObject):
    def __init__(self, grid=None, parent=None):
        super().__init__()
        self.parent = parent
        self.grid = grid
        self.boxes = {}
        self.idbox = 0
        self.init(self.grid)

    def init(self, grid):
        for i in range(5):
            self.idbox += 1
            b = Box("Frame #{}".format(self.idbox))
            b.addTo(grid)
            b.closedBox.connect(self.closeBox)
            self.boxes.setdefault(b.getId(),b)
            self.addTitleEditor(b.getGrid())
        self.spacer = QSpacerItem(0,0,QSizePolicy.Fixed,QSizePolicy.Expanding)
        self.addToGrid(self.grid,self.spacer)

    Slot(str)
    def closeBox(self, uuid):
        qDebug("Closing {}".format(uuid))
        b = self.boxes.get(uuid,None)
        if b:
            del self.boxes[uuid]
            self.grid.removeWidget(b)
            b.deleteLater()
            if len(self.boxes) == 0:
                self.grid.removeItem(self.spacer)
                self.init(self.grid)
            self.grid.update()

    def addToGrid(self, on, what, x=None, y=None ):
        if y is None:
            y = on.rowCount()
        if x is None:
            for i in range(on.columnCount()):
                if on.itemAtPosition(y,i) is None:
                    x = i
                    break

        if isinstance(what,QWidget):
            on.addWidget(what,y,x)
            return
        if isinstance(what,QLayoutItem):
            on.addItem(what,y,x)
            return
        if isinstance(what,list):
            all_widget = True
            all_list = True
            for i in what:
                if not isinstance(i,QWidget):
                    all_widget = False
                if not isinstance(i,list):
                    all_list = False
            if all_widget:
                for i in what:
                    self.addToGrid(on,i)
            if all_list:
                all_widget = True
                for i in what:
                    for j in i:
                        if not isinstance(j,QWidget):
                            all_widget = False
                            break
                    if not all_widget:
                        break
                if not all_widget:
                    qDebug("Error")
                    return
                else:
                    offset_x=0
                    for i in what:
                        for j in i:
                            self.addToGrid(on,j,x+offset_x,y)
                            offset_x+=1
        return

    def addTitleEditor(self, on):
        label = QLabel("Title")
        textedit = QTextEdit()
        self.addToGrid(on,[[label,textedit]])
        

class AppMainWindow(QApplication):
    def __init__(self):
        super().__init__([])
        self.menu = {}
        self.window = self.loadUi()
        self.window.show()
        self.addMenuItem(["one","two"],["some","other",["menuitem"]])
        self.bind_toolbar_actions()
        self.tableQuestions = tableHelper(self.window.tableWidgetQuestions, self)
        self.tableQuestions.editingQuestion.connect(self.editingQuestion)
        self.window.scrollAreaAnswers.setVerticalScrollBarPolicy( Qt.ScrollBarAlwaysOn )
        self.scroll = gridHelper(self.window.gridEdition, self)
        self.window.previewButton.clicked.connect(self.clickedPreview)
        self.sheet = None

    @Slot(int)
    def editingQuestion(self, row):
        qDebug("Editing {}".format(row))

    @Slot(bool)
    def clickedPreview(self,checked):
        qDebug("Preview clicked!")
        if not self.sheet:
            self.sheet = helperPDF(parent=self)
        self.sheet.openWidget()

    def loadUi(self):
        ui_file = QFile("mainwindow.ui")
        ui_file.open(QFile.ReadOnly)
        ui_loader = QUiLoader(self)
        window = ui_loader.load(ui_file)
        ui_file.close()
        return window

    def bind_toolbar_actions(self):
        for action in dir(self.window):
            action_obj = getattr(self.window,action)
            if isinstance(action_obj,QAction):
                action_obj.setData(action_obj.text())
                action_obj.triggered.connect(self.test)

    @Slot()
    def test(self):
        data = self.sender().data()
        qDebug("senderData:{}".format(data))
        self.window.statusbar.showMessage("Action from '{}' triggered".format(data),10*1000)
        self.tableQuestions.addItem(data)
        pass

    def calculate_default_menubar_shortcut(self,name):
        used = []
        for item in self.menu:
            for character in item:
                if character in used:
                    continue
                else:
                    used.append(character)
                    break
        newname = ""
        done = False
        for character in name:
            if done or character in used:
                newname += character
            else:
                newname += "&" + character
                done = True

        return newname

    def addMenuItem(self, *args, **kwargs):
        for name in args:
            if isinstance(name,list):
                self.addMenuItem(*name)
                continue
            if not isinstance(name,str) or name in self.menu:
                continue
            name_with_shortcut = self.calculate_default_menubar_shortcut(name)
            self.menu.setdefault(name,[])
            self.menu[name].append(self.window.menubar.addMenu(name_with_shortcut))
            action = Helper.genAction(name=name,fn=self.test,icon=TESTICON,tip=name,parent=self.menu[name][0],data=name)
            self.menu[name][0].addAction(action)

if __name__ == "__main__":
    QApplication.setAttribute(Qt.AA_ShareOpenGLContexts)
    app = AppMainWindow()
    sys.exit(app.exec_())
