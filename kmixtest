#!/usr/bin/env python3

# This Python file uses the following encoding: utf-8

import sys
# TODO: Remove unnecessary imports
from PySide2.QtCore import qDebug, Qt, QObject, Signal, Slot, QFile, QAbstractTableModel, QPoint, QRectF, QSizeF, QSize, Signal
from PySide2.QtWidgets import QApplication, QAction, QTableWidgetItem, QMenu, QToolBar
from PySide2.QtUiTools import QUiLoader
from PySide2.QtGui import QIcon, QKeySequence, QCursor, QTextDocument, QTextCursor, QPainter, QPageSize, QTextTableFormat, QTextImageFormat, QTextBlockFormat, QTextCharFormat, QFont, QBrush, QTextLength, QImage
from PySide2.QtPrintSupport import QPrinter
from PySide2.QtPrintSupport import QPrintPreviewWidget, QPrintPreviewDialog
import PySide2
TESTICON="option.svg"
TESTICONLINKED="linked.svg"

class Helper():
    def __init__(self):
        pass

    def genAction(self, name=None, fn=None, data=None, icon=None, shortcut=None, tip=None, parent=None):
        if name and fn:
            if icon:
                if isinstance(icon,str):
                    icon = QIcon(icon)
                elif isinstance(icon,QIcon):
                    pass
                else:
                    icon = None
            if icon:
                action = QAction(icon,name,parent)
            else:
                action = QAction(name,parent)
            
            if data != None:
                action.setData(data)

            if shortcut:
                if isinstance(shortcut,QKeySequence):
                    pass
                else:
                    try:
                        shortcut = QKeySequence(shortcut)
                    except:
                        shortcut = None
            if shortcut:
                action.setShortcuts(shortcut)
            
            if tip and isinstance(tip,str):
                action.setStatusTip(tip)

            action.triggered.connect(fn)

            return action
        return None

class tableHelper(QObject):
    def __init__(self, controller=None, table=None):
        QObject.__init__(self)
        if controller:
            self.controller = controller
        if table:
            self.setTableView(table)

    def setTableView(self, table):
        self.table = table
        self.model = table.model()
        self.table.setContextMenuPolicy(Qt.CustomContextMenu)
        self.table.customContextMenuRequested.connect(self.customMenu)
        self.table.cellClicked.connect(self.cellClicked)

    @Slot(int, int)
    def cellClicked(self, row, column):
        if column == 0:
            self.makeLinkedAction(row)

    @Slot(QPoint)
    def customMenu(self, position):
        qDebug("{}".format(position))
        item = self.table.itemAt(position)
        qDebug("item on x:{} y:{} with value {}".format(item.column(),item.row(),item.text()))
        qm = QMenu('titulo', self.table)
        if item.column()!=0:
            for seq in range(1,4):
                qm.addAction(Helper().genAction(name="ContextAction{}_{}".format(seq,item.text()),fn=self.printContextAction,data="ContextAction_{}_Data".format(seq,item.text()),icon=TESTICON,shortcut=None,tip="TipContextAction_{}".format(seq,item.text()),parent=qm))
            qm.addAction(Helper().genAction(name="Delete line '{}'".format(item.text()),fn=self.deleteContextAction,data=item.row(),icon=TESTICON,shortcut=None,tip="TipContextAction_Delete_{}".format(item.text()),parent=qm))
        else:
            self.makeLinkedAction(item.row())
        qm.exec_(QCursor.pos())
    
    @Slot()
    def printContextAction(self):
        data = self.sender().data()
        qDebug("senderData:{}".format(data))
        if self.controller:
            self.controller.window.statusbar.showMessage("Action from '{}' triggered".format(data),10*1000)

    @Slot()
    def deleteContextAction(self):
        data = self.sender().data()
        self.table.removeRow(data)
        if self.controller:
            self.controller.window.statusbar.showMessage("Deleted row {}".format(data),10*1000)

    def addItem(self, item):
        last_row = self.table.rowCount()
        self.table.insertRow(last_row)
        if not isinstance(item,list) and self.table.columnCount() >= 2:
            first_element = QTableWidgetItem(QIcon(),"")
            last_element = QTableWidgetItem("{}".format(item))
            itemlist = [first_element]
            for i in range(self.table.columnCount()-2):
                itemlist.append(QTableWidgetItem(""))
            itemlist.append(last_element)
        for i in range(len(itemlist)):
            self.table.setItem(last_row,i,itemlist[i])

    def makeLinkedAction(self, row):
        item = self.table.item(row,0)
        if item.icon():
            item.setIcon(QIcon())
        else:
            item.setIcon(QIcon(TESTICONLINKED))

class previewPrinter(QPrintPreviewDialog):
    toolbar = None
    actions = None
    orientation = None
    changedOrientation = Signal(QPrinter.Orientation)

    def __init__(self):
        self.parent = super()
        super().__init__()
        self.preview = self.findChild(QPrintPreviewWidget)
        self.orientation = QPrinter.Portrait
        self.toolbar = self.findChild(QToolBar)
        self.actions = { a.iconText() : a for a in self.toolbar.actions() if (type(a) == type(QAction()) and a.isVisible()) and not a.isSeparator() }
        self.setupButtons()
    
    def setupButtons(self):
        newActions = {'Landscape': self.triggeredOrientation, 'Portrait': self.triggeredOrientation }
        for a in self.actions:
            print('{}'.format(a))
            if a in newActions:
                qDebug("Into action {}".format(a))
                self.actions.get(a).triggered.disconnect()         
                self.actions.get(a).triggered.connect(newActions.get(a))

    @Slot(bool)
    def triggeredOrientation(self,checked):
        sender = self.sender().iconText()
        if sender == "Portrait":
            self.orientation = QPrinter.Portrait
        if sender == "Landscape":
            self.orientation = QPrinter.Landscape
        self.changedOrientation.emit(self.orientation)

    def updatePreview(self):
        self.preview.setOrientation(self.orientation)


class helperPDF():

    pageMargin = 10
    header_table_cols = 3
    header_table_rows = 2
    screen_orientation = Qt.PortraitOrientation
    printer_orientation = QPrinter.Portrait
    printer = None
    resolution = None
    document = None
    constPaperScreen = None
    cursor = None
    widget = None
    styles = None


    def __init__(self):
        self.widget = self.initWidget()
        pass

    def initPrinter(self, printer=None, resolution=QPrinter.HighResolution, margins=None):
        default_printer = QPrinter(resolution)
        if not printer:
            if self.printer:
                printer = self.printer
            else:
                self.printer = default_printer
                printer = default_printer

        if not resolution:
            if self.resolution:
                resolution = self.resolution
            else:
                resolution = QPrinter(QPrinter.HighResolution).resolution()
                self.resolution = resolution
        if isinstance(resolution,QPrinter.PrinterMode):
            resolution = QPrinter(resolution).resolution()
        printer.setResolution(resolution)
        qDebug("Setting orientation to {}".format(self.printer_orientation))
        printer.setOrientation(self.printer_orientation)

        PaperToScreen = int( resolution / QPrinter(QPrinter.ScreenResolution).resolution() )
        if self.constPaperScreen is None:
            self.constPaperScreen = PaperToScreen
        
        if margins is None:
            if self.pageMargin:
                margins = self.pageMargin
            else:
                margins = 10
                self.pageMargin = margins
        
        printer.setPageMargins(margins, margins, margins, margins, QPrinter.Millimeter)
        return printer, resolution, PaperToScreen

    def initDocument(self, printer=None, document=None):
        if not printer:
            printer = self.printer
        if not document:
            document = QTextDocument()
        if not self.document:
            self.document = document
        document.setPageSize(QSize(printer.pageRect().size()))
        return document

    def initWidget(self, widget=None):
        if not widget:
            widget = previewPrinter()
        if not self.widget:
            self.widget = widget
        widget.paintRequested.connect(self.paintRequest)
        widget.changedOrientation.connect(self.changedOrientation)
        return widget 

    def openWidget(self):
        self.widget.exec_()

    def initStyles(self, constant=None, styles=None):
        if constant is None:
            if self.constPaperScreen:
                constant = self.constPaperScreen
            else:
                constant = 1
                self.constPaperScreen = constant
        if not styles:
            styles = {}
            self.styles = styles

        if not 'header.table' in styles:
            styles.setdefault('header.table',QTextTableFormat())
        styles['header.table'].setBorderStyle(QTextTableFormat.BorderStyle_Solid)
        styles['header.table'].setBorder(1.0)
        styles['header.table'].setBorderBrush(QBrush(Qt.black,Qt.SolidPattern))
        styles['header.table'].setMargin(0.0)
        styles['header.table'].setCellSpacing(0.0)
        styles['header.table'].setCellPadding(10 * constant)
        styles['header.table'].setColumnWidthConstraints([ QTextLength(QTextLength.PercentageLength, 95/self.header_table_cols) ] * self.header_table_cols)

        styles['centerH'] = QTextBlockFormat()
        styles['centerH'].setAlignment(Qt.AlignCenter)
        # TODO: merge styles + use table cell format
        styles['centerV'] = QTextCharFormat()
        styles['centerV'].setVerticalAlignment(QTextCharFormat.VerticalAlignment.AlignMiddle)

        styles['text'] = QTextCharFormat()
        styles['text'].setFont(QFont("Times",10 * constant))
        return styles

    @Slot(QPrinter.Orientation)
    def changedOrientation(self, orientation):
        self.printer_orientation = orientation
        if orientation == QPrinter.Portrait:
            self.screen_orientation = Qt.Orientation.Horizontal
        else:
            self.screen_orientation = Qt.Orientation.Vertical
        self.widget.setOrientation(self.screen_orientation)
        self.widget.updatePreview()
        pass

    @Slot(QPrinter)
    def paintRequest(self, printer=None):
        self.printer, self.resolution, self.constPaperScreen = self.initPrinter()
        self.document = self.initDocument()
        self.styles = self.initStyles()
        qDebug('{} {} {}'.format(self.document.pageSize(),self.printer.paperRect(),self.printer.pageLayout().orientation()))
        document = self.makeHeaderTable(self.document,self.styles['header.table'] )
        document.print_(printer)
        

    def makeHeaderTable(self, document, style, rows = header_table_rows, cols = header_table_cols, images = {'left':'college.png','center':'department.jpg'}):
        def setupCell(row=0,col=0):
            cell = table.cellAt(row,col)
            cursor = cell.firstCursorPosition()
            cursor.setBlockFormat(self.styles['centerH'])
            cell.setFormat(self.styles['centerV'])
            return cursor
        
        max_image_width = (document.pageSize() / cols).width()
        max_image_height = (document.pageSize() / 6).height() # no big headers!
        def imageResized(name):
            image = QImage(name)
            new_image_height = image.height() * max_image_width / image.width()
            image = image.scaled(max_image_width,new_image_height,Qt.KeepAspectRatio,Qt.SmoothTransformation)
            if image.height() > max_image_height:
                new_image_width = image.width() * max_image_height / image.height()
                image = image.scaled(new_image_width,max_image_height,Qt.KeepAspectRatio,Qt.SmoothTransformation)
            return image

        cursor = QTextCursor(document)

        table = cursor.insertTable(rows,cols,self.styles['header.table'])
        first_element_row = 1
        first_element_col = 0
        num_rows = 1
        num_cols = cols

        table.mergeCells(first_element_row,first_element_col,num_rows,num_cols)
    
        cursor = setupCell(0,0)
        cursor.insertImage(imageResized(images['left']))

        cursor = setupCell(0,1)
        cursor.insertImage(imageResized(images['center']))
    
        from random import randint
        a = randint(3,20)
        b = randint(3,20)

        cursor = setupCell(0,2)
        cursor.insertText("Lorem ipsum " * a, self.styles['text'])

        cursor = setupCell(1,0)
        cursor.insertText("Lorem ipsum " * b, self.styles['text'])

        return document

class AppMainWindow(QApplication):
    def __init__(self):
        super().__init__([])
        self.menu = {}
        self.window = self.loadUi()
        self.window.show()
        self.addMenuItem(["one","two"],["some","other",["menuitem"]])
        self.bind_toolbar_actions()
        self.tableQuestions = tableHelper(self,self.window.tableWidgetQuestions)
        self.window.previewButton.clicked.connect(self.clickedPreview)
        self.sheet = helperPDF()
        self.clickedPreview(True)

    @Slot(bool)
    def clickedPreview(self,checked):
        qDebug("Preview clicked!")
        self.sheet.openWidget()

    def loadUi(self):
        ui_file = QFile("mainwindow.ui")
        ui_file.open(QFile.ReadOnly)
        ui_loader = QUiLoader(self)
        window = ui_loader.load(ui_file)
        ui_file.close()
        return window

    def bind_toolbar_actions(self):
        for action in dir(self.window):
            action_obj = getattr(self.window,action)
            if isinstance(action_obj,QAction):
                action_obj.setData(action_obj.text())
                action_obj.triggered.connect(self.test)

    @Slot()
    def test(self):
        data = self.sender().data()
        qDebug("senderData:{}".format(data))
        self.window.statusbar.showMessage("Action from '{}' triggered".format(data),10*1000)
        self.tableQuestions.addItem(data)
        pass

    def calculate_default_menubar_shortcut(self,name):
        used = []
        for item in self.menu:
            for character in item:
                if character in used:
                    continue
                else:
                    used.append(character)
                    break
        newname = ""
        done = False
        for character in name:
            if done or character in used:
                newname += character
            else:
                newname += "&" + character
                done = True

        return newname

    def addMenuItem(self, *args, **kwargs):
        for name in args:
            if isinstance(name,list):
                self.addMenuItem(*name)
                continue
            if not isinstance(name,str) or name in self.menu:
                continue
            name_with_shortcut = self.calculate_default_menubar_shortcut(name)
            self.menu.setdefault(name,[])
            self.menu[name].append(self.window.menubar.addMenu(name_with_shortcut))
            action = Helper().genAction(name=name,fn=self.test,icon=TESTICON,tip=name,parent=self.menu[name][0],data=name)
            self.menu[name][0].addAction(action)

if __name__ == "__main__":
    QApplication.setAttribute(Qt.AA_ShareOpenGLContexts)
    app = AppMainWindow()
    sys.exit(app.exec_())
