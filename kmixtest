#!/usr/bin/env python3

# This Python file uses the following encoding: utf-8

import sys

from PySide2.QtCore import qDebug, Qt, QObject, Signal, Slot, QFile, QAbstractTableModel, QPoint
from PySide2.QtWidgets import QApplication, QAction, QTableWidgetItem, QMenu
from PySide2.QtUiTools import QUiLoader
from PySide2.QtGui import QIcon, QKeySequence, QCursor

TESTICON="/usr/share/icons/breeze/actions/32/arrow.svg"
class Helper():
    def __init__(self):
        pass

    def genAction(self, name=None, fn=None, data=None, icon=None, shortcut=None, tip=None, parent=None):
        if name and fn:
            if icon:
                if isinstance(icon,str):
                    icon = QIcon(icon)
                elif isinstance(icon,QIcon):
                    pass
                else:
                    icon = None
            if icon:
                action = QAction(icon,name,parent)
            else:
                action = QAction(name,parent)
            
            if data != None:
                action.setData(data)

            if shortcut:
                if isinstance(shortcut,QKeySequence):
                    pass
                else:
                    try:
                        shortcut = QKeySequence(shortcut)
                    except:
                        shortcut = None
            if shortcut:
                action.setShortcuts(shortcut)
            
            if tip and isinstance(tip,str):
                action.setStatusTip(tip)

            action.triggered.connect(fn)

            return action
        return None

class tableHelper(QObject):
    def __init__(self, controller=None, table=None):
        QObject.__init__(self)
        if controller:
            self.controller = controller
        if table:
            self.setTableView(table)

    def setTableView(self, table):
        self.table = table
        self.model = table.model()
        self.table.setContextMenuPolicy(Qt.CustomContextMenu)
        self.table.customContextMenuRequested.connect(self.customMenu)

    @Slot(QPoint)
    def customMenu(self, position):
        qDebug("{}".format(position))
        item = self.table.itemAt(position)
        qDebug("item on x:{} y:{} with value {}".format(item.column(),item.row(),item.text()))
        qm = QMenu('titulo', self.table)
        for seq in range(1,4):
            qm.addAction(Helper().genAction(name="ContextAction{}_{}".format(seq,item.text()),fn=self.printContextAction,data="ContextAction_{}_Data".format(seq,item.text()),icon=TESTICON,shortcut=None,tip="TipContextAction_{}".format(seq,item.text()),parent=qm))
        qm.addAction(Helper().genAction(name="Delete line '{}'".format(item.text()),fn=self.deleteContextAction,data=item.row(),icon=TESTICON,shortcut=None,tip="TipContextAction_Delete_{}".format(item.text()),parent=qm))
        qm.exec_(QCursor.pos())
    
    @Slot()
    def printContextAction(self):
        data = self.sender().data()
        qDebug("senderData:{}".format(data))
        if self.controller:
            self.controller.window.statusbar.showMessage("Action from '{}' triggered".format(data),10*1000)

    @Slot()
    def deleteContextAction(self):
        data = self.sender().data()
        self.table.removeRow(data)
        if self.controller:
            self.controller.window.statusbar.showMessage("Deleted row {}".format(data),10*1000)

    def addItem(self, item):
        last = self.table.rowCount()
        self.table.insertRow(last)
        if not isinstance(item,list):
            item = [item]
        for i in range(len(item)):
            qitem = QTableWidgetItem(item[i])
            self.table.setItem(last,i,qitem)


class AppMainWindow(QApplication):
    def __init__(self):
        QApplication.__init__(self,[])
        self.menu = {}
        self.window = self.loadUi()
        self.window.show()
        self.addMenuItem(["one","two"],["some","other",["menuitem"]])
        self.bind_toolbar_actions()
        self.tableQuestions = tableHelper(self,self.window.tableWidgetQuestions)

    def loadUi(self):
        ui_file = QFile("mainwindow.ui")
        ui_file.open(QFile.ReadOnly)
        ui_loader = QUiLoader(self)
        window = ui_loader.load(ui_file)
        ui_file.close()
        return window

    def bind_toolbar_actions(self):
        for action in dir(self.window):
            action_obj = getattr(self.window,action)
            if isinstance(action_obj,QAction):
                action_obj.setData(action_obj.text())
                action_obj.triggered.connect(self.test)

    @Slot()
    def test(self):
        data = self.sender().data()
        qDebug("senderData:{}".format(data))
        self.window.statusbar.showMessage("Action from '{}' triggered".format(data),10*1000)
        self.tableQuestions.addItem(["",data])
        pass

    def calculate_default_menubar_shortcut(self,name):
        used = []
        for item in self.menu:
            for character in item:
                if character in used:
                    continue
                else:
                    used.append(character)
                    break
        newname = ""
        done = False
        for character in name:
            if done or character in used:
                newname += character
            else:
                newname += "&" + character
                done = True

        return newname

    def addMenuItem(self, *args, **kwargs):
        for name in args:
            if isinstance(name,list):
                self.addMenuItem(*name)
                continue
            if not isinstance(name,str) or name in self.menu:
                continue
            name_with_shortcut = self.calculate_default_menubar_shortcut(name)
            self.menu.setdefault(name,[])
            self.menu[name].append(self.window.menubar.addMenu(name_with_shortcut))
            action = Helper().genAction(name=name,fn=self.test,icon=TESTICON,tip=name,parent=self.menu[name][0],data=name)
            self.menu[name][0].addAction(action)


    

if __name__ == "__main__":
    QApplication.setAttribute(Qt.AA_ShareOpenGLContexts)
    app = AppMainWindow()
    sys.exit(app.exec_())
