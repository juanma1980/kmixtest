#!/usr/bin/env python3

# This Python file uses the following encoding: utf-8

import sys

from PySide2.QtCore import *
from PySide2.QtWidgets import *
from PySide2.QtGui import *
from PySide2.QtPrintSupport import *
from PySide2.QtUiTools import *
TESTICON="option.svg"
TESTICONLINKED="linked.svg"
TESTICONFIXED="fixed.svg"

def print_preview_data(preview):
    orientation = preview.orientation().name.decode()
    viewmode = preview.viewMode().name.decode()
    zoommode = preview.zoomMode().name.decode()
    currentPage = preview.currentPage()
    pagecount = preview.pageCount()
    qDebug("(Preview)  {} {} {} {}/{}".format(orientation, viewmode, zoommode, currentPage, pagecount))

def marginsToString(margins):
    return "{} {} {} {}".format(margins.left(),margins.top(),margins.right(),margins.bottom())

def print_printer_data(printer):
    pr = printer.paperRect()
    layout = printer.pageLayout()
    margins = layout.margins()
    size = layout.pageSize().id().name.decode()
    units = layout.units().name.decode()
    qDebug("(Printer)  Rect: {}x{} Size: {} Margins: {} Unit: {}".format(pr.width(),pr.height(),size,marginsToString(margins),units))

def print_document_data(document):
    size = document.pageSize()
    qDebug('(document) Rect: {}x{}'.format(int(size.width()),int(size.height())))

class Helper():
    def __init__(self):
        pass
    @staticmethod
    def genAction(name=None, fn=None, data=None, icon=None, shortcut=None, tip=None, parent=None):
        if name and fn:
            if icon:
                if isinstance(icon,str):
                    icon = QIcon(icon)
                elif isinstance(icon,QIcon):
                    pass
                else:
                    icon = None
            if icon:
                action = QAction(icon,name,parent)
            else:
                action = QAction(name,parent)
            
            if data != None:
                action.setData(data)

            if shortcut:
                if isinstance(shortcut,QKeySequence):
                    pass
                else:
                    try:
                        shortcut = QKeySequence(shortcut)
                    except:
                        shortcut = None
            if shortcut:
                action.setShortcuts(shortcut)
            
            if tip and isinstance(tip,str):
                action.setStatusTip(tip)

            action.triggered.connect(fn)

            return action
        return None       
class tableDrawer(QStyledItemDelegate):
    def __init__(self, helper):
        super().__init__()
        self.parent = helper
        self.iconFixed = QIcon(TESTICONFIXED)
        self.iconLinked = QIcon(TESTICONLINKED)
        self.icons = ["go-up.svg","go-down.svg"]
        self.widgets = []
        for i in self.icons:
            w = QPushButton()
            w.setIcon(QIcon(i))
            #w.setText("UP")
            #w.setToolButtonStyle(Qt.ToolButtonStyle.ToolButtonIconOnly)
            self.widgets.append(w)

    #def createEditor(self, parent, option, index):
    #    qDebug("CREATE EDITOR")
    #    return super().createEditor(parent, option, index)
    #def setEditorData(self, editor, index):
    #    qDebug("SET EDITOR DATA")
    #    return super().setEditorData(editor, index)
    #def setModelData(self, editor, model, index):
    #    qDebug("SET MODEL DATA")
    #    return super().setModelData(editor, model, index)
    #def sizeHint(self, option, index):
    #    qDebug("SIZE HINT")
    #    return super().sizeHint(option, index)
    #def updateEditorGeometry(self, editor, option, index):
    #    qDebug("UPDATE EDITOR GEOMETRY")
    #    return super().updateEditorGeometry(editor, option, index)
    #def eventFilter(self, editor, event):
    #    handled = super().eventFilter(editor, event)
    #    qDebug("EVENT FILTER {} {} {}".format(editor, event, handled))
    #    return handled

    def editorEvent(self, event, model, option, index):
        #qDebug("EDITOR EVENT")
        column = index.column()
        if column == 0:
            if event.type() == QEvent.MouseButtonRelease:
                offset = option.rect.width() / 2
                if event.x() > offset:
                    go = 'DOWN'
                else:
                    go = 'UP'
                self.parent.cellMoveClick.emit(index.row(),go)
                #qDebug("Release on {} {} row({}) {}".format(event.x(),event.y(),index.row(),go))
            return True # Mark all events on column 0 handled
            # Events on column 0 ends here
        if index.column() < 3:
            return True # Mark events on cols 1,2 as handled after emitting custom signal
            # Events on columns 1, 2 ends here

        # Column 3 (text) does not handle event here
        return super().editorEvent(event, model, option, index) # same as return False

    def paint(self, painter, option, index):
        if not index.isValid():
            return
        #if option.state & QStyle.State_Enabled:
        #    qDebug("Painting because state enabled")
        #if option.state & QStyle.State_MouseOver:
        #    qDebug("Painting becaused state mouseover")
        column = index.column()
        if column == 0:
            idx = 0
            count = len(self.widgets)
            size_available = option.rect.width() / count
            for w in self.widgets:
                painter.save()
                ws = w.style()
                opt = QStyleOptionButton()
                opt.rect = option.rect.translated(idx*size_available,0)
                opt.rect.setWidth(size_available)
                #opt.text = "{}".format(idx)
                opt.icon = w.icon()
                #opt.iconSize = QSize(option.rect.height(),option.rect.height())
                opt.state = ws.State_Enabled
                #QApplication.style().drawControl(ws.CE_PushButton,opt,painter,w)
                ws.drawControl(ws.CE_PushButton,opt,painter,w)
                painter.restore()
                idx+=1
        else:
            data = index.data(Qt.DisplayRole)
            if column == 1:
                col_icon = self.iconFixed
            if column == 2:
                col_icon = self.iconLinked
            
            if column != 3:
                if data == True:
                    option.icon = col_icon
                else:
                    option.icon = QIcon()
                option.text = ""
                option.decorationSize = QSize(option.rect.height(), option.rect.height())
                # Must to set position if alignment need to be setted
                option.decorationPosition = QStyleOptionViewItem.Top
                option.decorationAlignment = Qt.AlignCenter 
            else:
                option.icon = QIcon()
                option.text = data

            if option.text:
                #super().paint(painter, option, index)
                # same as next call
                option.widget.style().drawControl(QStyle.CE_ItemViewItem,option,painter,option.widget)
            if option.icon or index.data(Qt.DecorationRole):
                option.icon.paint(painter,option.rect,option.decorationAlignment,QIcon.Mode.Normal,QIcon.State.On)


class tableHelper(QObject):
    cellMoveClick = Signal(int,str)
    def __init__(self, controller=None, table=None):
        QObject.__init__(self)
        if controller:
            self.controller = controller
        if table:
            self.setTableView(table)
            self.cellMoveClick.connect(self.moveRow)
            table.setItemDelegate(tableDrawer(self))

    def setTableView(self, table):
        self.table = table
        # Maybe create own model in future
        # (model) QStandardItemModel(0,5)
        # (view) setModel(self.model)
        self.table.setColumnCount(5)
        self.model = table.model()
        # Last column is hidden, private data here
        self.table.setColumnHidden(self.table.columnCount()-1,True)
        self.configureHeader()
        self.table.setContextMenuPolicy(Qt.CustomContextMenu)
        self.table.customContextMenuRequested.connect(self.customMenu)
        self.table.cellClicked.connect(self.ClickOnCell)

    def configureHeader(self):
        header  = self.table.horizontalHeader()
        for i in range(self.table.columnCount()-1):
                header.setSectionResizeMode(i,QHeaderView.ResizeToContents)
        #self.table.horizontalHeader().setStretchLastSection(True)
        pass

    @Slot(int, int)
    def ClickOnCell(self, row, column):
        if column in [1,2]:
            idx=self.model.index(row,column)
            data=self.model.data(idx,Qt.DisplayRole)
            data = not data
            self.model.setData(idx,data,Qt.DisplayRole)
            return True

    @Slot(QPoint)
    def customMenu(self, position):
        item = self.table.itemAt(position)
        if not item:
            qDebug("No item on that position!")
            return
        qDebug("item on x:{} y:{} with value {}".format(item.column(),item.row(),item.text()))
        qm = QMenu('titulo', self.table)
        if item.column()!=0:
            for seq in range(1,4):
                qm.addAction(Helper.genAction(name="ContextAction{}_{}".format(seq,item.text()),fn=self.printContextAction,data="ContextAction_{}_Data".format(seq,item.text()),icon=TESTICON,shortcut=None,tip="TipContextAction_{}".format(seq,item.text()),parent=qm))
            qm.addAction(Helper.genAction(name="Delete line '{}'".format(item.text()),fn=self.deleteContextAction,data=item.row(),icon=TESTICON,shortcut=None,tip="TipContextAction_Delete_{}".format(item.text()),parent=qm))
        else:
            self.makeLinkedAction(item.row())
        qm.exec_(QCursor.pos())
    
    @Slot()
    def printContextAction(self):
        data = self.sender().data()
        qDebug("senderData:{}".format(data))
        if self.controller:
            self.controller.window.statusbar.showMessage("Action from '{}' triggered".format(data),10*1000)

    @Slot()
    def deleteContextAction(self):
        data = self.sender().data()
        self.table.removeRow(data)
        if self.controller:
            self.controller.window.statusbar.showMessage("Deleted row {}".format(data),10*1000)

    @Slot(int,str)
    def moveRow(self,row,dir):
        insert = False
        if dir == 'UP' and row != 0:
            row += 1
            onrow = row -2
            insert = True
        if dir == 'DOWN' and row != self.table.rowCount() -1:
            onrow = row +2
            insert = True
        if not insert:
            #qDebug("Can't move")
            return
        #qDebug('Moving {} {}'.format(row,dir))
        self.table.insertRow(onrow)
        for col in range(self.table.columnCount()):
            self.table.setItem(onrow,col,self.table.takeItem(row,col))
        self.table.removeRow(row)

    def makeRow(self, item="", table=None):
        if table is None and self.table is not None:
            table = self.table
        last_row = table.rowCount()
        table.insertRow(last_row)
        # Columns 1,2,3 alignment & size is set from delegated class
        table.setItem(last_row,0,QTableWidgetItem())

        for col in [1,2]:
            idx=self.model.index(last_row,col)
            self.model.setData(idx,False,Qt.DisplayRole)

        i = QTableWidgetItem("{}".format(item))
        i.setTextAlignment(Qt.AlignLeft | Qt.AlignVCenter)
        table.setItem(last_row,3,i)
        
        col = self.table.columnCount() -1
        idx=self.model.index(last_row,col)
        # Store as UserRole into hidden column
        self.model.setData(idx,"{}".format(item),Qt.UserRole)

    def addItem(self, item):
        if item and isinstance(item,list):
            for i in item:
                self.addItem(i)
        else:
            self.makeRow(item)


class previewPrinter(QPrintPreviewDialog):
    toolbar = None
    actions = None

    def __init__(self, parent=None, printer=None):
        if parent is not None:
            self.parent = parent
        super().__init__(printer)
        self.preview = self.findChild(QPrintPreviewWidget)
        #self.toolbar = self.findChild(QToolBar)
        #self.actions = { a.iconText() : a for a in self.toolbar.actions() if (type(a) == type(QAction()) and a.isVisible()) and not a.isSeparator() }
        self.setupButtons()
    
    def setupButtons(self):
        self.preview.previewChanged.connect(self.previewChanged)

    @Slot()
    def previewChanged(self):
        qDebug("***** Preview changed! *****")
        print_preview_data(self.preview)
        print_printer_data(self.parent.printer)

class helperPDF():

    header_table_cols = 3
    header_table_rows = 2

    def __init__(self, parent=None):
        self.parent = parent
        self.pageMargins = QMarginsF(10,10,10,10)
        self.orientation = QPageLayout.Orientation.Portrait
        self.layout = None
        self.printer = None
        self.resolution = QPrinter.HighResolution
        self.constPaperScreen = None
        self.document = None
        self.cursor = None
        self.styles = None
        self.widget = None
        self.printer, self.resolution, self.constPaperScreen, self.layout = self.initPrinter(printer=self.printer, resolution=self.resolution, margins=self.pageMargins, orientation=self.orientation)
        self.widget = self.initWidget(parent=self, printer=self.printer)
        pass

    def initPrinter(self, printer=None, resolution=QPrinter.HighResolution, margins=None, orientation=None):
        
        if not resolution:
            if self.resolution:
                resolution = self.resolution
            else:
                resolution = QPrinter(QPrinter.HighResolution).resolution()
                self.resolution = resolution
        
        if isinstance(resolution,QPrinter.PrinterMode):
            default_printer = QPrinter(resolution)
            resolution = QPrinter(resolution).resolution()
        else:
            default_printer = QPrinter()
            default_printer.setResolution(resolution)
            
        if not printer:
            if self.printer:
                printer = self.printer
            else:
                self.printer = default_printer
                printer = default_printer

        if printer.resolution() != resolution:
            printer.setResolution(resolution)
        
        current_layout = self.printer.pageLayout()
        changed_layout = False
        if current_layout.units() != QPageLayout.Millimeter:
            current_layout.setUnits(QPageLayout.Millimeter)
            changed_layout = True

        if margins is not None and isinstance(margins,QMarginsF):
            qDebug("Setting margins to {}".format(marginsToString(margins)))
            current_layout.setMargins(margins)
            changed_layout = True
        else:
            self.pageMargins = current_layout.margins()
        
        if orientation is not None and isinstance(orientation, QPageLayout.Orientation):
            qDebug("Setting orientation to {}".format(orientation.name.decode()))
            current_layout.setOrientation(orientation)
            changed_layout = True

        if changed_layout:
            printer.setPageLayout(current_layout)

        PaperToScreen = int( resolution / QPrinter(QPrinter.ScreenResolution).resolution() )
        self.constPaperScreen = PaperToScreen
        qDebug("Setting constant: {}".format(int(self.constPaperScreen)))

        relTextToA4 = int(self.printer.pageSizeMM().width()/210.0)
        self.relTextToA4 = relTextToA4
        qDebug("Setting text multiplier size: {}".format(relTextToA4))

        return printer, resolution, PaperToScreen, current_layout

    def initDocument(self, printer=None, document=None):
        if not printer:
            printer = self.printer
        if not document:
            document = QTextDocument()
        if not self.document:
            self.document = document
        document.setPageSize(QSize(printer.pageRect().size()))
        self.initStyles()
        return document

    def initWidget(self, parent=None, printer=None):
        
        widget = previewPrinter(parent=parent,printer=printer)
        if not self.widget:
            self.widget = widget
        widget.paintRequested.connect(self.paintRequest)
        return widget 

    def openWidget(self):
        self.widget.exec_()

    def initStyles(self, styles=None):
        
        if not styles:
            styles = {}
            self.styles = styles

        if not 'header.table' in styles:
            styles.setdefault('header.table',QTextTableFormat())
        styles['header.table'].setBorderStyle(QTextTableFormat.BorderStyle_Solid)
        styles['header.table'].setBorder(1.0)
        styles['header.table'].setBorderBrush(QBrush(Qt.black,Qt.SolidPattern))
        styles['header.table'].setMargin(0.0)
        styles['header.table'].setCellSpacing(0.0)
        styles['header.table'].setCellPadding(10 * self.constPaperScreen)
        styles['header.table'].setColumnWidthConstraints([ QTextLength(QTextLength.PercentageLength, 95/self.header_table_cols) ] * self.header_table_cols)

        styles['centerH'] = QTextBlockFormat()
        styles['centerH'].setAlignment(Qt.AlignCenter)
        
        styles['centerV'] = QTextCharFormat()
        styles['centerV'].setVerticalAlignment(QTextCharFormat.VerticalAlignment.AlignMiddle)

        styles['text'] = QTextCharFormat()
        
        qDebug("Using text multiplier size: {}".format(int(self.relTextToA4)))
        styles['text'].setFont(QFont("Times",10 * self.constPaperScreen * self.relTextToA4))
        return styles


    @Slot(QPrinter)
    def paintRequest(self, printer=None):
        qDebug("***** Repaint Event ! *****")

        self.initPrinter(printer)
        self.document = self.initDocument(printer = self.printer)

        print_document_data(self.document)
        print_printer_data(printer)

        document = self.makeHeaderTable(self.document,self.styles['header.table'] )
        document.print_(printer)
        

    def makeHeaderTable(self, document, style, rows = header_table_rows, cols = header_table_cols, images = {'left':'college.png','center':'department.jpg'}):
        def setupCell(row=0,col=0):
            cell = table.cellAt(row,col)
            cursor = cell.firstCursorPosition()
            cursor.setBlockFormat(self.styles['centerH'])
            cell.setFormat(self.styles['centerV'])
            return cursor
        
        max_image_width = (document.pageSize() / cols).width()
        max_image_height = (document.pageSize() / 6).height() # no big headers!
        def imageResized(name):
            image = QImage(name)
            new_image_height = image.height() * max_image_width / image.width()
            image = image.scaled(max_image_width,new_image_height,Qt.KeepAspectRatio,Qt.SmoothTransformation)
            if image.height() > max_image_height:
                new_image_width = image.width() * max_image_height / image.height()
                image = image.scaled(new_image_width,max_image_height,Qt.KeepAspectRatio,Qt.SmoothTransformation)
            return image

        cursor = QTextCursor(document)

        table = cursor.insertTable(rows,cols,self.styles['header.table'])
        first_element_row = 1
        first_element_col = 0
        num_rows = 1
        num_cols = cols

        table.mergeCells(first_element_row,first_element_col,num_rows,num_cols)
    
        cursor = setupCell(0,0)
        cursor.insertImage(imageResized(images['left']))

        cursor = setupCell(0,1)
        cursor.insertImage(imageResized(images['center']))
    
        from random import randint
        a = randint(3,20)
        b = randint(3,20)

        cursor = setupCell(0,2)
        cursor.insertText("Lorem ipsum " * a, self.styles['text'])

        cursor = setupCell(1,0)
        cursor.insertText("Lorem ipsum " * b, self.styles['text'])

        return document

class AppMainWindow(QApplication):
    def __init__(self):
        super().__init__([])
        self.menu = {}
        self.window = self.loadUi()
        self.window.show()
        self.addMenuItem(["one","two"],["some","other",["menuitem"]])
        self.bind_toolbar_actions()
        self.tableQuestions = tableHelper(self,self.window.tableWidgetQuestions)
        self.window.previewButton.clicked.connect(self.clickedPreview)
        self.sheet = helperPDF(parent=self)

    @Slot(bool)
    def clickedPreview(self,checked):
        qDebug("Preview clicked!")
        self.sheet.openWidget()

    def loadUi(self):
        ui_file = QFile("mainwindow.ui")
        ui_file.open(QFile.ReadOnly)
        ui_loader = QUiLoader(self)
        window = ui_loader.load(ui_file)
        ui_file.close()
        return window

    def bind_toolbar_actions(self):
        for action in dir(self.window):
            action_obj = getattr(self.window,action)
            if isinstance(action_obj,QAction):
                action_obj.setData(action_obj.text())
                action_obj.triggered.connect(self.test)

    @Slot()
    def test(self):
        data = self.sender().data()
        qDebug("senderData:{}".format(data))
        self.window.statusbar.showMessage("Action from '{}' triggered".format(data),10*1000)
        self.tableQuestions.addItem(data)
        pass

    def calculate_default_menubar_shortcut(self,name):
        used = []
        for item in self.menu:
            for character in item:
                if character in used:
                    continue
                else:
                    used.append(character)
                    break
        newname = ""
        done = False
        for character in name:
            if done or character in used:
                newname += character
            else:
                newname += "&" + character
                done = True

        return newname

    def addMenuItem(self, *args, **kwargs):
        for name in args:
            if isinstance(name,list):
                self.addMenuItem(*name)
                continue
            if not isinstance(name,str) or name in self.menu:
                continue
            name_with_shortcut = self.calculate_default_menubar_shortcut(name)
            self.menu.setdefault(name,[])
            self.menu[name].append(self.window.menubar.addMenu(name_with_shortcut))
            action = Helper.genAction(name=name,fn=self.test,icon=TESTICON,tip=name,parent=self.menu[name][0],data=name)
            self.menu[name][0].addAction(action)

if __name__ == "__main__":
    QApplication.setAttribute(Qt.AA_ShareOpenGLContexts)
    app = AppMainWindow()
    sys.exit(app.exec_())
